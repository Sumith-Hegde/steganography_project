{"ast":null,"code":"function embedMessageInImage(imageURL, message) {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const image = new Image();\n\n    image.onload = function () {\n      canvas.width = image.width;\n      canvas.height = image.height;\n      context.drawImage(image, 0, 0); // Convert the message to binary\n\n      const binaryMessage = message.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join('');\n      const messageLength = binaryMessage.length;\n      let bitIndex = 0;\n\n      for (let y = 0; y < canvas.height; y++) {\n        for (let x = 0; x < canvas.width; x++) {\n          const pixel = context.getImageData(x, y, 1, 1).data;\n\n          if (bitIndex < messageLength) {\n            const bit = binaryMessage.charAt(bitIndex); // Set the least significant bit of each channel to the message bit\n\n            pixel[0] = pixel[0] & 0xfe | Number(bit);\n            pixel[1] = pixel[1] & 0xfe | Number(bit);\n            pixel[2] = pixel[2] & 0xfe | Number(bit);\n            context.putImageData(new ImageData(pixel, 1, 1), x, y);\n            bitIndex++;\n          } else {\n            break;\n          }\n        }\n      } // Convert the canvas image to data URL\n\n\n      const modifiedImageURL = canvas.toDataURL();\n      resolve(modifiedImageURL);\n    };\n\n    image.onerror = function () {\n      reject(new Error('Failed to load image.'));\n    };\n\n    image.src = imageURL;\n  });\n}\n\nfunction decodeMessageFromImage(modifiedImageURL) {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.crossOrigin = 'anonymous';\n\n    image.onload = function () {\n      const canvas = document.createElement('canvas');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      const context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0);\n      const binaryMessage = [];\n      let bitIndex = 0;\n      let messageEnd = false;\n\n      for (let y = 0; y < canvas.height; y++) {\n        for (let x = 0; x < canvas.width; x++) {\n          const pixel = context.getImageData(x, y, 1, 1).data;\n          const redBit = pixel[0] & 0x01;\n          binaryMessage.push(redBit);\n          bitIndex++;\n\n          if (bitIndex % 8 === 0) {\n            const byte = binaryMessage.join('');\n            binaryMessage.length = 0; // Clear the array\n\n            if (byte === '00000000') {\n              messageEnd = true;\n              break;\n            }\n\n            const charCode = parseInt(byte, 2);\n            const char = String.fromCharCode(charCode);\n            binaryMessage.push(char);\n          }\n        }\n\n        if (messageEnd) {\n          break;\n        }\n      }\n\n      if (messageEnd) {\n        const originalMessage = binaryMessage.join('');\n        resolve(originalMessage);\n      } else {\n        reject(new Error('No message found in the image.'));\n      }\n    };\n\n    image.onerror = function () {\n      reject(new Error('Failed to load image.'));\n    };\n\n    image.src = modifiedImageURL;\n  });\n}\n\nmodule.exports = {\n  encode: embedMessageInImage,\n  decode: decodeMessageFromImage\n}; // steganogarphy.decode(newURL).then((originalMessage) => {\n//   console.log('Original Message:', originalMessage);\n// })","map":{"version":3,"sources":["D:/VS_Code/VS_Code_general_Workspace/finalYearProject/chatApp/src/components/steganogarphy.js"],"names":["embedMessageInImage","imageURL","message","Promise","resolve","reject","canvas","document","createElement","context","getContext","image","Image","onload","width","height","drawImage","binaryMessage","split","map","char","charCodeAt","toString","padStart","join","messageLength","length","bitIndex","y","x","pixel","getImageData","data","bit","charAt","Number","putImageData","ImageData","modifiedImageURL","toDataURL","onerror","Error","src","decodeMessageFromImage","crossOrigin","messageEnd","redBit","push","byte","charCode","parseInt","String","fromCharCode","originalMessage","module","exports","encode","decode"],"mappings":"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","sourcesContent":["function embedMessageInImage(imageURL, message) {\r\n  return new Promise((resolve, reject) => {\r\n    const canvas = document.createElement('canvas');\r\n    const context = canvas.getContext('2d');\r\n    const image = new Image();\r\n\r\n    image.onload = function() {\r\n      canvas.width = image.width;\r\n      canvas.height = image.height;\r\n      context.drawImage(image, 0, 0);\r\n\r\n      // Convert the message to binary\r\n      const binaryMessage = message\r\n        .split('')\r\n        .map((char) => char.charCodeAt(0).toString(2).padStart(8, '0'))\r\n        .join('');\r\n\r\n      const messageLength = binaryMessage.length;\r\n      let bitIndex = 0;\r\n\r\n      for (let y = 0; y < canvas.height; y++) {\r\n        for (let x = 0; x < canvas.width; x++) {\r\n          const pixel = context.getImageData(x, y, 1, 1).data;\r\n\r\n          if (bitIndex < messageLength) {\r\n            const bit = binaryMessage.charAt(bitIndex);\r\n            // Set the least significant bit of each channel to the message bit\r\n            pixel[0] = (pixel[0] & 0xfe) | Number(bit);\r\n            pixel[1] = (pixel[1] & 0xfe) | Number(bit);\r\n            pixel[2] = (pixel[2] & 0xfe) | Number(bit);\r\n            context.putImageData(new ImageData(pixel, 1, 1), x, y);\r\n            bitIndex++;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Convert the canvas image to data URL\r\n      const modifiedImageURL = canvas.toDataURL();\r\n      resolve(modifiedImageURL);\r\n    };\r\n\r\n    image.onerror = function() {\r\n      reject(new Error('Failed to load image.'));\r\n    };\r\n\r\n    image.src = imageURL;\r\n  });\r\n}\r\n\r\nfunction decodeMessageFromImage(modifiedImageURL) {\r\n  return new Promise((resolve, reject) => {\r\n    const image = new Image();\r\n    image.crossOrigin = 'anonymous';\r\n\r\n    image.onload = function() {\r\n      const canvas = document.createElement('canvas');\r\n      canvas.width = image.width;\r\n      canvas.height = image.height;\r\n\r\n      const context = canvas.getContext('2d');\r\n      context.drawImage(image, 0, 0);\r\n\r\n      const binaryMessage = [];\r\n      let bitIndex = 0;\r\n      let messageEnd = false;\r\n\r\n      for (let y = 0; y < canvas.height; y++) {\r\n        for (let x = 0; x < canvas.width; x++) {\r\n          const pixel = context.getImageData(x, y, 1, 1).data;\r\n\r\n          const redBit = pixel[0] & 0x01;\r\n          binaryMessage.push(redBit);\r\n          bitIndex++;\r\n\r\n          if (bitIndex % 8 === 0) {\r\n            const byte = binaryMessage.join('');\r\n            binaryMessage.length = 0; // Clear the array\r\n\r\n            if (byte === '00000000') {\r\n              messageEnd = true;\r\n              break;\r\n            }\r\n\r\n            const charCode = parseInt(byte, 2);\r\n            const char = String.fromCharCode(charCode);\r\n            binaryMessage.push(char);\r\n          }\r\n        }\r\n\r\n        if (messageEnd) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (messageEnd) {\r\n        const originalMessage = binaryMessage.join('');\r\n        resolve(originalMessage);\r\n      } else {\r\n        reject(new Error('No message found in the image.'));\r\n      }\r\n    };\r\n\r\n    image.onerror = function() {\r\n      reject(new Error('Failed to load image.'));\r\n    };\r\n\r\n    image.src = modifiedImageURL;\r\n  });\r\n}\r\n\r\n\r\nmodule.exports={\r\n  encode:embedMessageInImage,\r\n  decode:decodeMessageFromImage\r\n};\r\n\r\n\r\n\r\n// steganogarphy.decode(newURL).then((originalMessage) => {\r\n//   console.log('Original Message:', originalMessage);\r\n// })\r\n"]},"metadata":{},"sourceType":"module"}