{"ast":null,"code":"function embedMessageInImage(imageURL, message) {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const image = new Image();\n\n    image.onload = function () {\n      canvas.width = image.width;\n      canvas.height = image.height;\n      context.drawImage(image, 0, 0); // Convert the message to binary\n\n      const binaryMessage = message.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join('');\n      let bitIndex = 0;\n      let messageEnd = false;\n\n      for (let y = 0; y < canvas.height; y++) {\n        for (let x = 0; x < canvas.width; x++) {\n          const pixel = context.getImageData(x, y, 1, 1).data;\n\n          if (!messageEnd) {\n            if (bitIndex < binaryMessage.length) {\n              const bit = binaryMessage.charAt(bitIndex); // Set the least significant bit of each channel to the message bit\n\n              pixel[0] = pixel[0] & 0xfe | Number(bit);\n              pixel[1] = pixel[1] & 0xfe | Number(bit);\n              pixel[2] = pixel[2] & 0xfe | Number(bit);\n              context.putImageData(new ImageData(pixel, 1, 1), x, y);\n              bitIndex++;\n            } else {\n              // Reached end of message, set the next bit as 1 to mark the end\n              pixel[0] |= 0x01;\n              pixel[1] |= 0x01;\n              pixel[2] |= 0x01;\n              context.putImageData(new ImageData(pixel, 1, 1), x, y);\n              messageEnd = true;\n            }\n          }\n        }\n      } // Convert the canvas image to data URL\n\n\n      const modifiedImageURL = canvas.toDataURL();\n      resolve(modifiedImageURL);\n    };\n\n    image.onerror = function () {\n      reject(new Error('Failed to load image.'));\n    };\n\n    image.src = imageURL;\n  });\n}\n\nfunction decodeMessageFromImage(modifiedImageURL) {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.crossOrigin = 'anonymous';\n\n    image.onload = function () {\n      const canvas = document.createElement('canvas');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      const context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0);\n      let binaryMessage = '';\n      let bitIndex = 0;\n      let messageBytes = [];\n      let messageLength = 0;\n      let messageEnd = false;\n\n      for (let y = 0; y < canvas.height; y++) {\n        for (let x = 0; x < canvas.width; x++) {\n          const pixel = context.getImageData(x, y, 1, 1).data;\n\n          if (!messageEnd) {\n            const redBit = pixel[0] & 0x01;\n            binaryMessage += redBit;\n            bitIndex++;\n\n            if (bitIndex === 8) {\n              const byte = parseInt(binaryMessage, 2);\n\n              if (messageLength === 0) {\n                messageLength = byte;\n              } else {\n                messageBytes.push(byte);\n\n                if (messageBytes.length === messageLength) {\n                  messageEnd = true;\n                  break;\n                }\n              }\n\n              binaryMessage = '';\n              bitIndex = 0;\n            }\n          }\n        }\n\n        if (messageEnd) {\n          break;\n        }\n      }\n\n      if (messageEnd) {\n        const originalMessage = messageBytes.map(byte => String.fromCharCode(byte)).join('');\n        resolve(originalMessage);\n      } else {\n        reject(new Error('No message found in the image.'));\n      }\n    };\n\n    image.onerror = function () {\n      reject(new Error('Failed to load image.'));\n    };\n\n    image.src = modifiedImageURL;\n  });\n}\n\nmodule.exports = {\n  encode: embedMessageInImage,\n  decode: decodeMessageFromImage\n}; // steganogarphy.decode(newURL).then((originalMessage) => {\n//   console.log('Original Message:', originalMessage);\n// })","map":{"version":3,"sources":["D:/VS_Code/VS_Code_general_Workspace/finalYearProject/chatApp/src/components/steganogarphy.js"],"names":["embedMessageInImage","imageURL","message","Promise","resolve","reject","canvas","document","createElement","context","getContext","image","Image","onload","width","height","drawImage","binaryMessage","split","map","char","charCodeAt","toString","padStart","join","bitIndex","messageEnd","y","x","pixel","getImageData","data","length","bit","charAt","Number","putImageData","ImageData","modifiedImageURL","toDataURL","onerror","Error","src","decodeMessageFromImage","crossOrigin","messageBytes","messageLength","redBit","byte","parseInt","push","originalMessage","String","fromCharCode","module","exports","encode","decode"],"mappings":"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","sourcesContent":["function embedMessageInImage(imageURL, message) {\r\n  return new Promise((resolve, reject) => {\r\n    const canvas = document.createElement('canvas');\r\n    const context = canvas.getContext('2d');\r\n    const image = new Image();\r\n\r\n    image.onload = function() {\r\n      canvas.width = image.width;\r\n      canvas.height = image.height;\r\n      context.drawImage(image, 0, 0);\r\n\r\n      // Convert the message to binary\r\n      const binaryMessage = message\r\n        .split('')\r\n        .map((char) => char.charCodeAt(0).toString(2).padStart(8, '0'))\r\n        .join('');\r\n\r\n      let bitIndex = 0;\r\n      let messageEnd = false;\r\n\r\n      for (let y = 0; y < canvas.height; y++) {\r\n        for (let x = 0; x < canvas.width; x++) {\r\n          const pixel = context.getImageData(x, y, 1, 1).data;\r\n\r\n          if (!messageEnd) {\r\n            if (bitIndex < binaryMessage.length) {\r\n              const bit = binaryMessage.charAt(bitIndex);\r\n              // Set the least significant bit of each channel to the message bit\r\n              pixel[0] = (pixel[0] & 0xfe) | Number(bit);\r\n              pixel[1] = (pixel[1] & 0xfe) | Number(bit);\r\n              pixel[2] = (pixel[2] & 0xfe) | Number(bit);\r\n              context.putImageData(new ImageData(pixel, 1, 1), x, y);\r\n              bitIndex++;\r\n            } else {\r\n              // Reached end of message, set the next bit as 1 to mark the end\r\n              pixel[0] |= 0x01;\r\n              pixel[1] |= 0x01;\r\n              pixel[2] |= 0x01;\r\n              context.putImageData(new ImageData(pixel, 1, 1), x, y);\r\n              messageEnd = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Convert the canvas image to data URL\r\n      const modifiedImageURL = canvas.toDataURL();\r\n      resolve(modifiedImageURL);\r\n    };\r\n\r\n    image.onerror = function() {\r\n      reject(new Error('Failed to load image.'));\r\n    };\r\n\r\n    image.src = imageURL;\r\n  });\r\n}\r\n\r\nfunction decodeMessageFromImage(modifiedImageURL) {\r\n  return new Promise((resolve, reject) => {\r\n    const image = new Image();\r\n    image.crossOrigin = 'anonymous'; \r\n\r\n    image.onload = function() {\r\n      const canvas = document.createElement('canvas');\r\n      canvas.width = image.width;\r\n      canvas.height = image.height;\r\n\r\n      const context = canvas.getContext('2d');\r\n      context.drawImage(image, 0, 0);\r\n\r\n      let binaryMessage = '';\r\n      let bitIndex = 0;\r\n      let messageBytes = [];\r\n      let messageLength = 0;\r\n      let messageEnd = false;\r\n\r\n      for (let y = 0; y < canvas.height; y++) {\r\n        for (let x = 0; x < canvas.width; x++) {\r\n          const pixel = context.getImageData(x, y, 1, 1).data;\r\n\r\n          if (!messageEnd) {\r\n            const redBit = pixel[0] & 0x01;\r\n            binaryMessage += redBit;\r\n            bitIndex++;\r\n\r\n            if (bitIndex === 8) {\r\n              const byte = parseInt(binaryMessage, 2);\r\n\r\n              if (messageLength === 0) {\r\n                messageLength = byte;\r\n              } else {\r\n                messageBytes.push(byte);\r\n\r\n                if (messageBytes.length === messageLength) {\r\n                  messageEnd = true;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              binaryMessage = '';\r\n              bitIndex = 0;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (messageEnd) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (messageEnd) {\r\n        const originalMessage = messageBytes\r\n          .map((byte) => String.fromCharCode(byte))\r\n          .join('');\r\n        resolve(originalMessage);\r\n      } else {\r\n        reject(new Error('No message found in the image.'));\r\n      }\r\n    };\r\n\r\n    image.onerror = function() {\r\n      reject(new Error('Failed to load image.'));\r\n    };\r\n\r\n    image.src = modifiedImageURL;\r\n  });\r\n}\r\n\r\nmodule.exports={\r\n  encode:embedMessageInImage,\r\n  decode:decodeMessageFromImage\r\n};\r\n\r\n\r\n\r\n// steganogarphy.decode(newURL).then((originalMessage) => {\r\n//   console.log('Original Message:', originalMessage);\r\n// })\r\n"]},"metadata":{},"sourceType":"module"}