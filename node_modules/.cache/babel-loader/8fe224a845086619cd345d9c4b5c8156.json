{"ast":null,"code":"function embedMessageInImage(imageURL, message) {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const image = new Image();\n\n    image.onload = function () {\n      canvas.width = image.width;\n      canvas.height = image.height;\n      context.drawImage(image, 0, 0); // Convert the message to binary\n\n      const binaryMessage = message.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join('');\n      const numPixels = canvas.width * canvas.height;\n      const stepSize = Math.ceil(binaryMessage.length / numPixels);\n      let messageIndex = 0;\n\n      for (let i = 0; i < numPixels; i++) {\n        const x = i % canvas.width;\n        const y = Math.floor(i / canvas.width);\n        const pixel = context.getImageData(x, y, 1, 1).data;\n\n        if (messageIndex < binaryMessage.length) {\n          const bit = binaryMessage.charAt(messageIndex); // Set the least significant bit of each channel to the message bit\n\n          pixel[0] = pixel[0] & 0xfe | Number(bit);\n          pixel[1] = pixel[1] & 0xfe | Number(bit);\n          pixel[2] = pixel[2] & 0xfe | Number(bit);\n          context.putImageData(new ImageData(pixel, 1, 1), x, y);\n          messageIndex++;\n        } else {\n          break;\n        }\n\n        messageIndex += stepSize - 1;\n      } // Convert the canvas image to data URL\n\n\n      const modifiedImageURL = canvas.toDataURL();\n      resolve(modifiedImageURL);\n    };\n\n    image.onerror = function () {\n      reject(new Error('Failed to load image.'));\n    };\n\n    image.src = imageURL;\n  });\n}\n\nfunction decodeMessageFromImage(modifiedImageURL) {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.crossOrigin = 'anonymous';\n\n    image.onload = function () {\n      const canvas = document.createElement('canvas');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      const context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0);\n      const numPixels = canvas.width * canvas.height;\n      const stepSize = Math.ceil(binaryMessage.length / numPixels);\n      let binaryMessage = '';\n      let messageIndex = 0;\n      let messageBytes = [];\n      let messageLength = 0;\n      let messageEnd = false;\n\n      for (let i = 0; i < numPixels; i++) {\n        const x = i % canvas.width;\n        const y = Math.floor(i / canvas.width);\n        const pixel = context.getImageData(x, y, 1, 1).data;\n\n        if (!messageEnd) {\n          const redBit = pixel[0] & 0x01;\n          binaryMessage += redBit;\n          messageIndex++;\n\n          if (messageIndex >= stepSize) {\n            messageIndex = 0;\n\n            if (binaryMessage.length === 8) {\n              const byte = parseInt(binaryMessage, 2);\n\n              if (messageLength === 0) {\n                messageLength = byte;\n              } else {\n                messageBytes.push(byte);\n\n                if (messageBytes.length === messageLength) {\n                  messageEnd = true;\n                  break;\n                }\n              }\n\n              binaryMessage = '';\n            }\n          }\n        }\n      }\n\n      if (messageEnd) {\n        const originalMessage = messageBytes.map(byte => String.fromCharCode(byte)).join('');\n        resolve(originalMessage);\n      } else {\n        reject(new Error('No message found in the image.'));\n      }\n    };\n\n    image.onerror = function () {\n      reject(new Error('Failed to load image.'));\n    };\n\n    image.src = modifiedImageURL;\n  });\n}\n\nmodule.exports = {\n  encode: embedMessageInImage,\n  decode: decodeMessageFromImage\n}; // steganogarphy.decode(newURL).then((originalMessage) => {\n//   console.log('Original Message:', originalMessage);\n// })","map":{"version":3,"sources":["D:/VS_Code/VS_Code_general_Workspace/finalYearProject/chatApp/src/components/steganogarphy.js"],"names":["embedMessageInImage","imageURL","message","Promise","resolve","reject","canvas","document","createElement","context","getContext","image","Image","onload","width","height","drawImage","binaryMessage","split","map","char","charCodeAt","toString","padStart","join","numPixels","stepSize","Math","ceil","length","messageIndex","i","x","y","floor","pixel","getImageData","data","bit","charAt","Number","putImageData","ImageData","modifiedImageURL","toDataURL","onerror","Error","src","decodeMessageFromImage","crossOrigin","messageBytes","messageLength","messageEnd","redBit","byte","parseInt","push","originalMessage","String","fromCharCode","module","exports","encode","decode"],"mappings":"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","sourcesContent":["function embedMessageInImage(imageURL, message) {\r\n  return new Promise((resolve, reject) => {\r\n    const canvas = document.createElement('canvas');\r\n    const context = canvas.getContext('2d');\r\n    const image = new Image();\r\n\r\n    image.onload = function() {\r\n      canvas.width = image.width;\r\n      canvas.height = image.height;\r\n      context.drawImage(image, 0, 0);\r\n\r\n      // Convert the message to binary\r\n      const binaryMessage = message\r\n        .split('')\r\n        .map((char) => char.charCodeAt(0).toString(2).padStart(8, '0'))\r\n        .join('');\r\n\r\n      const numPixels = canvas.width * canvas.height;\r\n      const stepSize = Math.ceil(binaryMessage.length / numPixels);\r\n\r\n      let messageIndex = 0;\r\n\r\n      for (let i = 0; i < numPixels; i++) {\r\n        const x = i % canvas.width;\r\n        const y = Math.floor(i / canvas.width);\r\n\r\n        const pixel = context.getImageData(x, y, 1, 1).data;\r\n\r\n        if (messageIndex < binaryMessage.length) {\r\n          const bit = binaryMessage.charAt(messageIndex);\r\n          // Set the least significant bit of each channel to the message bit\r\n          pixel[0] = (pixel[0] & 0xfe) | Number(bit);\r\n          pixel[1] = (pixel[1] & 0xfe) | Number(bit);\r\n          pixel[2] = (pixel[2] & 0xfe) | Number(bit);\r\n          context.putImageData(new ImageData(pixel, 1, 1), x, y);\r\n          messageIndex++;\r\n        } else {\r\n          break;\r\n        }\r\n\r\n        messageIndex += stepSize - 1;\r\n      }\r\n\r\n      // Convert the canvas image to data URL\r\n      const modifiedImageURL = canvas.toDataURL();\r\n      resolve(modifiedImageURL);\r\n    };\r\n\r\n    image.onerror = function() {\r\n      reject(new Error('Failed to load image.'));\r\n    };\r\n\r\n    image.src = imageURL;\r\n  });\r\n}\r\n\r\nfunction decodeMessageFromImage(modifiedImageURL) {\r\n  return new Promise((resolve, reject) => {\r\n    const image = new Image();\r\n    image.crossOrigin = 'anonymous';\r\n\r\n    image.onload = function() {\r\n      const canvas = document.createElement('canvas');\r\n      canvas.width = image.width;\r\n      canvas.height = image.height;\r\n\r\n      const context = canvas.getContext('2d');\r\n      context.drawImage(image, 0, 0);\r\n\r\n      const numPixels = canvas.width * canvas.height;\r\n      const stepSize = Math.ceil(binaryMessage.length / numPixels);\r\n\r\n      let binaryMessage = '';\r\n      let messageIndex = 0;\r\n      let messageBytes = [];\r\n      let messageLength = 0;\r\n      let messageEnd = false;\r\n\r\n      for (let i = 0; i < numPixels; i++) {\r\n        const x = i % canvas.width;\r\n        const y = Math.floor(i / canvas.width);\r\n\r\n        const pixel = context.getImageData(x, y, 1, 1).data;\r\n\r\n        if (!messageEnd) {\r\n          const redBit = pixel[0] & 0x01;\r\n          binaryMessage += redBit;\r\n          messageIndex++;\r\n\r\n          if (messageIndex >= stepSize) {\r\n            messageIndex = 0;\r\n\r\n            if (binaryMessage.length === 8) {\r\n              const byte = parseInt(binaryMessage, 2);\r\n\r\n              if (messageLength === 0) {\r\n                messageLength = byte;\r\n              } else {\r\n                messageBytes.push(byte);\r\n\r\n                if (messageBytes.length === messageLength) {\r\n                  messageEnd = true;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              binaryMessage = '';\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (messageEnd) {\r\n        const originalMessage = messageBytes\r\n          .map((byte) => String.fromCharCode(byte))\r\n          .join('');\r\n        resolve(originalMessage);\r\n      } else {\r\n        reject(new Error('No message found in the image.'));\r\n      }\r\n    };\r\n\r\n    image.onerror = function() {\r\n      reject(new Error('Failed to load image.'));\r\n    };\r\n\r\n    image.src = modifiedImageURL;\r\n  });\r\n}\r\n\r\n\r\n\r\nmodule.exports={\r\n  encode:embedMessageInImage,\r\n  decode:decodeMessageFromImage\r\n};\r\n\r\n\r\n\r\n// steganogarphy.decode(newURL).then((originalMessage) => {\r\n//   console.log('Original Message:', originalMessage);\r\n// })\r\n"]},"metadata":{},"sourceType":"module"}