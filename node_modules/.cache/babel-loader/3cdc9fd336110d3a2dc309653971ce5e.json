{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.types = exports.setConcurrency = exports.disableTypes = exports.disableFS = exports.imageSize = void 0;\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst queue_1 = require(\"queue\");\n\nconst types_1 = require(\"./types\");\n\nconst detector_1 = require(\"./detector\"); // Maximum buffer size, with a default of 512 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\n\n\nconst MaxBufferSize = 512 * 1024; // This queue is for async `fs` operations, to avoid reaching file-descriptor limits\n\nconst queue = new queue_1.default({\n  concurrency: 100,\n  autostart: true\n});\nconst globalOptions = {\n  disabledFS: false,\n  disabledTypes: []\n};\n/**\n * Return size information based on a buffer\n *\n * @param {Buffer} buffer\n * @param {String} filepath\n * @returns {Object}\n */\n\nfunction lookup(buffer, filepath) {\n  // detect the file type.. don't rely on the extension\n  const type = (0, detector_1.detector)(buffer);\n\n  if (typeof type !== 'undefined') {\n    if (globalOptions.disabledTypes.indexOf(type) > -1) {\n      throw new TypeError('disabled file type: ' + type);\n    } // find an appropriate handler for this file type\n\n\n    if (type in types_1.typeHandlers) {\n      const size = types_1.typeHandlers[type].calculate(buffer, filepath);\n\n      if (size !== undefined) {\n        size.type = type;\n        return size;\n      }\n    }\n  } // throw up, if we don't understand the file\n\n\n  throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');\n}\n/**\n * Reads a file into a buffer.\n * @param {String} filepath\n * @returns {Promise<Buffer>}\n */\n\n\nasync function asyncFileToBuffer(filepath) {\n  const handle = await fs.promises.open(filepath, 'r');\n\n  try {\n    const {\n      size\n    } = await handle.stat();\n\n    if (size <= 0) {\n      throw new Error('Empty file');\n    }\n\n    const bufferSize = Math.min(size, MaxBufferSize);\n    const buffer = Buffer.alloc(bufferSize);\n    await handle.read(buffer, 0, bufferSize, 0);\n    return buffer;\n  } finally {\n    await handle.close();\n  }\n}\n/**\n * Synchronously reads a file into a buffer, blocking the nodejs process.\n *\n * @param {String} filepath\n * @returns {Buffer}\n */\n\n\nfunction syncFileToBuffer(filepath) {\n  // read from the file, synchronously\n  const descriptor = fs.openSync(filepath, 'r');\n\n  try {\n    const {\n      size\n    } = fs.fstatSync(descriptor);\n\n    if (size <= 0) {\n      throw new Error('Empty file');\n    }\n\n    const bufferSize = Math.min(size, MaxBufferSize);\n    const buffer = Buffer.alloc(bufferSize);\n    fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n    return buffer;\n  } finally {\n    fs.closeSync(descriptor);\n  }\n} // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\nmodule.exports = exports = imageSize; // backwards compatibility\n\nexports.default = imageSize;\n/**\n * @param {Buffer|string} input - buffer or relative/absolute path of the image file\n * @param {Function=} [callback] - optional function for async detection\n */\n\nfunction imageSize(input, callback) {\n  // Handle buffer input\n  if (Buffer.isBuffer(input)) {\n    return lookup(input);\n  } // input should be a string at this point\n\n\n  if (typeof input !== 'string' || globalOptions.disabledFS) {\n    throw new TypeError('invalid invocation. input should be a Buffer');\n  } // resolve the file path\n\n\n  const filepath = path.resolve(input);\n\n  if (typeof callback === 'function') {\n    queue.push(() => asyncFileToBuffer(filepath).then(buffer => process.nextTick(callback, null, lookup(buffer, filepath))).catch(callback));\n  } else {\n    const buffer = syncFileToBuffer(filepath);\n    return lookup(buffer, filepath);\n  }\n}\n\nexports.imageSize = imageSize;\n\nconst disableFS = v => {\n  globalOptions.disabledFS = v;\n};\n\nexports.disableFS = disableFS;\n\nconst disableTypes = types => {\n  globalOptions.disabledTypes = types;\n};\n\nexports.disableTypes = disableTypes;\n\nconst setConcurrency = c => {\n  queue.concurrency = c;\n};\n\nexports.setConcurrency = setConcurrency;\nexports.types = Object.keys(types_1.typeHandlers);","map":{"version":3,"sources":["D:/VS_Code/VS_Code_general_Workspace/finalYearProject/chatApp/node_modules/image-size/dist/index.js"],"names":["Object","defineProperty","exports","value","types","setConcurrency","disableTypes","disableFS","imageSize","fs","require","path","queue_1","types_1","detector_1","MaxBufferSize","queue","default","concurrency","autostart","globalOptions","disabledFS","disabledTypes","lookup","buffer","filepath","type","detector","indexOf","TypeError","typeHandlers","size","calculate","undefined","asyncFileToBuffer","handle","promises","open","stat","Error","bufferSize","Math","min","Buffer","alloc","read","close","syncFileToBuffer","descriptor","openSync","fstatSync","readSync","closeSync","module","input","callback","isBuffer","resolve","push","then","process","nextTick","catch","v","c","keys"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.types = exports.setConcurrency = exports.disableTypes = exports.disableFS = exports.imageSize = void 0;\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst queue_1 = require(\"queue\");\nconst types_1 = require(\"./types\");\nconst detector_1 = require(\"./detector\");\n// Maximum buffer size, with a default of 512 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\nconst MaxBufferSize = 512 * 1024;\n// This queue is for async `fs` operations, to avoid reaching file-descriptor limits\nconst queue = new queue_1.default({ concurrency: 100, autostart: true });\nconst globalOptions = {\n    disabledFS: false,\n    disabledTypes: []\n};\n/**\n * Return size information based on a buffer\n *\n * @param {Buffer} buffer\n * @param {String} filepath\n * @returns {Object}\n */\nfunction lookup(buffer, filepath) {\n    // detect the file type.. don't rely on the extension\n    const type = (0, detector_1.detector)(buffer);\n    if (typeof type !== 'undefined') {\n        if (globalOptions.disabledTypes.indexOf(type) > -1) {\n            throw new TypeError('disabled file type: ' + type);\n        }\n        // find an appropriate handler for this file type\n        if (type in types_1.typeHandlers) {\n            const size = types_1.typeHandlers[type].calculate(buffer, filepath);\n            if (size !== undefined) {\n                size.type = type;\n                return size;\n            }\n        }\n    }\n    // throw up, if we don't understand the file\n    throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');\n}\n/**\n * Reads a file into a buffer.\n * @param {String} filepath\n * @returns {Promise<Buffer>}\n */\nasync function asyncFileToBuffer(filepath) {\n    const handle = await fs.promises.open(filepath, 'r');\n    try {\n        const { size } = await handle.stat();\n        if (size <= 0) {\n            throw new Error('Empty file');\n        }\n        const bufferSize = Math.min(size, MaxBufferSize);\n        const buffer = Buffer.alloc(bufferSize);\n        await handle.read(buffer, 0, bufferSize, 0);\n        return buffer;\n    }\n    finally {\n        await handle.close();\n    }\n}\n/**\n * Synchronously reads a file into a buffer, blocking the nodejs process.\n *\n * @param {String} filepath\n * @returns {Buffer}\n */\nfunction syncFileToBuffer(filepath) {\n    // read from the file, synchronously\n    const descriptor = fs.openSync(filepath, 'r');\n    try {\n        const { size } = fs.fstatSync(descriptor);\n        if (size <= 0) {\n            throw new Error('Empty file');\n        }\n        const bufferSize = Math.min(size, MaxBufferSize);\n        const buffer = Buffer.alloc(bufferSize);\n        fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n        return buffer;\n    }\n    finally {\n        fs.closeSync(descriptor);\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-use-before-define\nmodule.exports = exports = imageSize; // backwards compatibility\nexports.default = imageSize;\n/**\n * @param {Buffer|string} input - buffer or relative/absolute path of the image file\n * @param {Function=} [callback] - optional function for async detection\n */\nfunction imageSize(input, callback) {\n    // Handle buffer input\n    if (Buffer.isBuffer(input)) {\n        return lookup(input);\n    }\n    // input should be a string at this point\n    if (typeof input !== 'string' || globalOptions.disabledFS) {\n        throw new TypeError('invalid invocation. input should be a Buffer');\n    }\n    // resolve the file path\n    const filepath = path.resolve(input);\n    if (typeof callback === 'function') {\n        queue.push(() => asyncFileToBuffer(filepath)\n            .then((buffer) => process.nextTick(callback, null, lookup(buffer, filepath)))\n            .catch(callback));\n    }\n    else {\n        const buffer = syncFileToBuffer(filepath);\n        return lookup(buffer, filepath);\n    }\n}\nexports.imageSize = imageSize;\nconst disableFS = (v) => { globalOptions.disabledFS = v; };\nexports.disableFS = disableFS;\nconst disableTypes = (types) => { globalOptions.disabledTypes = types; };\nexports.disableTypes = disableTypes;\nconst setConcurrency = (c) => { queue.concurrency = c; };\nexports.setConcurrency = setConcurrency;\nexports.types = Object.keys(types_1.typeHandlers);\n"]},"metadata":{},"sourceType":"script"}