{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Encryptor = void 0;\n\nconst isInteger_1 = __importDefault(require(\"lodash/isInteger\"));\n\nconst bit_stuffing_1 = require(\"./bit-stuffing\");\n\nconst buffer_to_bit_coverter_1 = require(\"./buffer-to-bit-coverter\");\n\nclass Encryptor {\n  constructor() {\n    this.bitStuffing = new bit_stuffing_1.BitStuffing();\n  }\n\n  encrypt(originalImage, secret, depth) {\n    const image = originalImage.clone();\n    const secretBuffer = Buffer.from(secret, 'utf-8');\n    const escapedSecret = Buffer.from([...this.bitStuffing.escape(secretBuffer)]);\n    const secretBits = buffer_to_bit_coverter_1.convertBufferToBits(escapedSecret);\n    const capacityBits = (image.bitmap.width * image.bitmap.height - 1) * 3 * depth;\n\n    if (capacityBits < secretBits.length) {\n      throw new Error(`Image too small. Capacity (with depth=${depth}) is ${capacityBits} bits. Secret requires ${secretBits.length} bits`);\n    }\n\n    const scanIterator = image.scanIterator(0, 0, image.bitmap.width, image.bitmap.height);\n\n    for (const {\n      x,\n      y,\n      idx\n    } of scanIterator) {\n      if (x === 0 && y === 0) {\n        this.setDepth(image, idx, depth);\n        continue;\n      }\n\n      const redBits = secretBits.splice(0, depth).join('').padEnd(depth, '0');\n      const redNumber = parseInt(redBits, 2);\n      image.bitmap.data[idx + 0] = this.applyRightMostBits(image.bitmap.data[idx + 0], depth, redNumber);\n      const greenBits = secretBits.splice(0, depth).join('').padEnd(depth, '0');\n      const greenNumber = parseInt(greenBits, 2);\n      image.bitmap.data[idx + 1] = this.applyRightMostBits(image.bitmap.data[idx + 1], depth, greenNumber);\n      const blueBits = secretBits.splice(0, depth).join('').padEnd(depth, '0');\n      const blueNumber = parseInt(blueBits, 2);\n      image.bitmap.data[idx + 2] = this.applyRightMostBits(image.bitmap.data[idx + 2], depth, blueNumber);\n\n      if (secretBits.length === 0) {\n        break;\n      }\n    }\n\n    return image;\n  }\n\n  decrypt(image) {\n    const scanIterator = image.scanIterator(0, 0, image.bitmap.width, image.bitmap.height);\n    let temp = '';\n    let buffer = Buffer.from([]);\n    let frameEndReceived = false;\n    let depth;\n\n    for (const {\n      x,\n      y,\n      idx\n    } of scanIterator) {\n      if (x === 0 && y === 0) {\n        depth = this.getDepth(image, idx);\n        continue;\n      }\n\n      const redBits = image.bitmap.data[idx + 0].toString(2).padStart(8, '0').slice(-depth);\n      temp += redBits;\n      const greenBits = image.bitmap.data[idx + 1].toString(2).padStart(8, '0').slice(-depth);\n      temp += greenBits;\n      const blueBits = image.bitmap.data[idx + 2].toString(2).padStart(8, '0').slice(-depth);\n      temp += blueBits;\n\n      while (temp.length >= 8) {\n        const bits = temp.split('');\n        const first8bits = bits.splice(0, 8);\n        temp = bits.join('');\n        const firstByte = parseInt(first8bits.join(''), 2);\n        buffer = Buffer.concat([buffer, Buffer.from([firstByte])]);\n\n        if (firstByte === bit_stuffing_1.BitStuffing.FE) {\n          frameEndReceived = true;\n          break;\n        }\n      }\n\n      if (frameEndReceived) {\n        break;\n      }\n    }\n\n    const unescapedSecret = Buffer.from([...this.bitStuffing.unescape(buffer)]);\n    const secret = unescapedSecret.toString('utf-8');\n    return secret;\n  }\n  /**\n   * Set depth to pixel at [0;0]\n   * @param image - image to be mutated\n   * @param depth - mow many bits used to store message info\n   *\n   * Examples:\n   *  depth == 1 => R := XXXXXXX0 G := XXXXXXX0 B := XXXXXXX1\n   *  depth == 2 => R := XXXXXXX0 G := XXXXXXX1 B := XXXXXXX0\n   *  depth == 3 => R := XXXXXXX0 G := XXXXXXX1 B := XXXXXXX1\n   *  depth == 4 => R := XXXXXXX1 G := XXXXXXX0 B := XXXXXXX0\n   *  depth == 5 => R := XXXXXXX1 G := XXXXXXX0 B := XXXXXXX1\n   *  depth == 6 => R := XXXXXXX1 G := XXXXXXX1 B := XXXXXXX0\n   *  depth == 7 => R := XXXXXXX1 G := XXXXXXX1 B := XXXXXXX1\n   */\n\n\n  setDepth(image) {\n    let idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let depth = arguments.length > 2 ? arguments[2] : undefined;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!isInteger_1.default(depth) || depth < 1 || depth > 7) {\n        throw new Error('Depth should be an integer from 1 to 7');\n      }\n\n      const redRightMost = (depth >> 2) % 2;\n      const greenRightMost = (depth >> 1) % 2;\n      const blueRightMost = (depth >> 0) % 2;\n      image.bitmap.data[idx + 0] = this.applyRightMostBits(image.bitmap.data[idx + 0], 1, redRightMost);\n      image.bitmap.data[idx + 1] = this.applyRightMostBits(image.bitmap.data[idx + 1], 1, greenRightMost);\n      image.bitmap.data[idx + 2] = this.applyRightMostBits(image.bitmap.data[idx + 2], 1, blueRightMost);\n    });\n  }\n\n  applyRightMostBits(value, depth, bits) {\n    const result = value - value % Math.pow(2, depth) + bits % Math.pow(2, depth);\n    return result;\n  }\n\n  getDepth(image, idx) {\n    const red = image.bitmap.data[idx + 0];\n    const green = image.bitmap.data[idx + 1];\n    const blue = image.bitmap.data[idx + 2];\n    return parseInt(`${red % 2}${green % 2}${blue % 2}`, 2);\n  }\n\n}\n\nexports.Encryptor = Encryptor;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AACA;;AACA;;AAEA,MAAaA,SAAb,CAAsB;AAGpBC;AACE,SAAKC,WAAL,GAAmB,IAAIC,0BAAJ,EAAnB;AACD;;AAEMC,SAAO,CAACC,aAAD,EAAsBC,MAAtB,EAAsCC,KAAtC,EAAmD;AAC/D,UAAMC,KAAK,GAAGH,aAAa,CAACI,KAAd,EAAd;AAEA,UAAMC,YAAY,GAAGC,MAAM,CAACC,IAAP,CAAYN,MAAZ,EAAoB,OAApB,CAArB;AACA,UAAMO,aAAa,GAAGF,MAAM,CAACC,IAAP,CAAY,CAAC,GAAG,KAAKV,WAAL,CAAiBY,MAAjB,CAAwBJ,YAAxB,CAAJ,CAAZ,CAAtB;AACA,UAAMK,UAAU,GAAGC,6CAAoBH,aAApB,CAAnB;AAEA,UAAMI,YAAY,GAAG,CAACT,KAAK,CAACU,MAAN,CAAaC,KAAb,GAAqBX,KAAK,CAACU,MAAN,CAAaE,MAAlC,GAA2C,CAA5C,IAAiD,CAAjD,GAAqDb,KAA1E;;AAEA,QAAIU,YAAY,GAAGF,UAAU,CAACM,MAA9B,EAAsC;AACpC,YAAM,IAAIC,KAAJ,CAAU,yCAAyCf,KAAK,QAAQU,YAAY,0BAA0BF,UAAU,CAACM,MAAM,OAAvH,CAAN;AACD;;AAED,UAAME,YAAY,GAAGf,KAAK,CAACe,YAAN,CAAmB,CAAnB,EAAsB,CAAtB,EAAyBf,KAAK,CAACU,MAAN,CAAaC,KAAtC,EAA6CX,KAAK,CAACU,MAAN,CAAaE,MAA1D,CAArB;;AAEA,SAAK,MAAM;AAAEI,OAAF;AAAKC,OAAL;AAAQC;AAAR,KAAX,IAA4BH,YAA5B,EAA0C;AACxC,UAAIC,CAAC,KAAK,CAAN,IAAWC,CAAC,KAAK,CAArB,EAAwB;AACtB,aAAKE,QAAL,CAAcnB,KAAd,EAAqBkB,GAArB,EAA0BnB,KAA1B;AACA;AACD;;AAED,YAAMqB,OAAO,GAAGb,UAAU,CAACc,MAAX,CAAkB,CAAlB,EAAqBtB,KAArB,EAA4BuB,IAA5B,CAAiC,EAAjC,EAAqCC,MAArC,CAA4CxB,KAA5C,EAAmD,GAAnD,CAAhB;AACA,YAAMyB,SAAS,GAAGC,QAAQ,CAACL,OAAD,EAAU,CAAV,CAA1B;AACApB,WAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,IAA6B,KAAKS,kBAAL,CAAwB3B,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,CAAxB,EAAoDnB,KAApD,EAA2DyB,SAA3D,CAA7B;AAEA,YAAMI,SAAS,GAAGrB,UAAU,CAACc,MAAX,CAAkB,CAAlB,EAAqBtB,KAArB,EAA4BuB,IAA5B,CAAiC,EAAjC,EAAqCC,MAArC,CAA4CxB,KAA5C,EAAmD,GAAnD,CAAlB;AACA,YAAM8B,WAAW,GAAGJ,QAAQ,CAACG,SAAD,EAAY,CAAZ,CAA5B;AACA5B,WAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,IAA6B,KAAKS,kBAAL,CAAwB3B,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,CAAxB,EAAoDnB,KAApD,EAA2D8B,WAA3D,CAA7B;AAEA,YAAMC,QAAQ,GAAGvB,UAAU,CAACc,MAAX,CAAkB,CAAlB,EAAqBtB,KAArB,EAA4BuB,IAA5B,CAAiC,EAAjC,EAAqCC,MAArC,CAA4CxB,KAA5C,EAAmD,GAAnD,CAAjB;AACA,YAAMgC,UAAU,GAAGN,QAAQ,CAACK,QAAD,EAAW,CAAX,CAA3B;AACA9B,WAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,IAA6B,KAAKS,kBAAL,CAAwB3B,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,CAAxB,EAAoDnB,KAApD,EAA2DgC,UAA3D,CAA7B;;AAEA,UAAIxB,UAAU,CAACM,MAAX,KAAsB,CAA1B,EAA6B;AAC3B;AACD;AACF;;AAGD,WAAOb,KAAP;AACD;;AAEMgC,SAAO,CAAChC,KAAD,EAAY;AACxB,UAAMe,YAAY,GAAGf,KAAK,CAACe,YAAN,CAAmB,CAAnB,EAAsB,CAAtB,EAAyBf,KAAK,CAACU,MAAN,CAAaC,KAAtC,EAA6CX,KAAK,CAACU,MAAN,CAAaE,MAA1D,CAArB;AAEA,QAAIqB,IAAI,GAAW,EAAnB;AACA,QAAIC,MAAM,GAAG/B,MAAM,CAACC,IAAP,CAAY,EAAZ,CAAb;AACA,QAAI+B,gBAAgB,GAAG,KAAvB;AACA,QAAIpC,KAAJ;;AAEA,SAAK,MAAM;AAAEiB,OAAF;AAAKC,OAAL;AAAQC;AAAR,KAAX,IAA4BH,YAA5B,EAA0C;AACxC,UAAIC,CAAC,KAAK,CAAN,IAAWC,CAAC,KAAK,CAArB,EAAwB;AACtBlB,aAAK,GAAG,KAAKqC,QAAL,CAAcpC,KAAd,EAAqBkB,GAArB,CAAR;AACA;AACD;;AAED,YAAME,OAAO,GAAGpB,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,EAA2BmB,QAA3B,CAAoC,CAApC,EAAuCC,QAAvC,CAAgD,CAAhD,EAAmD,GAAnD,EAAwDC,KAAxD,CAA8D,CAACxC,KAA/D,CAAhB;AACAkC,UAAI,IAAIb,OAAR;AAEA,YAAMQ,SAAS,GAAG5B,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,EAA2BmB,QAA3B,CAAoC,CAApC,EAAuCC,QAAvC,CAAgD,CAAhD,EAAmD,GAAnD,EAAwDC,KAAxD,CAA8D,CAACxC,KAA/D,CAAlB;AACAkC,UAAI,IAAIL,SAAR;AAEA,YAAME,QAAQ,GAAG9B,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,EAA2BmB,QAA3B,CAAoC,CAApC,EAAuCC,QAAvC,CAAgD,CAAhD,EAAmD,GAAnD,EAAwDC,KAAxD,CAA8D,CAACxC,KAA/D,CAAjB;AACAkC,UAAI,IAAIH,QAAR;;AAEA,aAAOG,IAAI,CAACpB,MAAL,IAAe,CAAtB,EAAyB;AACvB,cAAM2B,IAAI,GAAGP,IAAI,CAACQ,KAAL,CAAW,EAAX,CAAb;AACA,cAAMC,UAAU,GAAGF,IAAI,CAACnB,MAAL,CAAY,CAAZ,EAAe,CAAf,CAAnB;AACAY,YAAI,GAAGO,IAAI,CAAClB,IAAL,CAAU,EAAV,CAAP;AAEA,cAAMqB,SAAS,GAAGlB,QAAQ,CAACiB,UAAU,CAACpB,IAAX,CAAgB,EAAhB,CAAD,EAAsB,CAAtB,CAA1B;AACAY,cAAM,GAAG/B,MAAM,CAACyC,MAAP,CAAc,CAACV,MAAD,EAAS/B,MAAM,CAACC,IAAP,CAAY,CAACuC,SAAD,CAAZ,CAAT,CAAd,CAAT;;AAEA,YAAIA,SAAS,KAAKhD,2BAAYkD,EAA9B,EAAkC;AAChCV,0BAAgB,GAAG,IAAnB;AACA;AACD;AACF;;AAED,UAAIA,gBAAJ,EAAsB;AACpB;AACD;AAEF;;AAED,UAAMW,eAAe,GAAG3C,MAAM,CAACC,IAAP,CAAY,CAAC,GAAG,KAAKV,WAAL,CAAiBqD,QAAjB,CAA0Bb,MAA1B,CAAJ,CAAZ,CAAxB;AACA,UAAMpC,MAAM,GAAGgD,eAAe,CAACT,QAAhB,CAAyB,OAAzB,CAAf;AAEA,WAAOvC,MAAP;AACD;AAED;;;;;;;;;;;;;;;;AAccqB,UAAQ,CAACnB,KAAD,EAA4C;AAAA,QAA9BkB,GAA8B,uEAAhB,CAAgB;AAAA,QAAbnB,KAAa;;AAChE,UAAI,CAACiD,oBAAUjD,KAAV,CAAD,IAAqBA,KAAK,GAAG,CAA7B,IAAkCA,KAAK,GAAG,CAA9C,EAAiD;AAC/C,cAAM,IAAIe,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAED,YAAMmC,YAAY,GAAG,CAAClD,KAAK,IAAI,CAAV,IAAe,CAApC;AACA,YAAMmD,cAAc,GAAG,CAACnD,KAAK,IAAI,CAAV,IAAe,CAAtC;AACA,YAAMoD,aAAa,GAAG,CAACpD,KAAK,IAAI,CAAV,IAAe,CAArC;AAEAC,WAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,IAA6B,KAAKS,kBAAL,CAAwB3B,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,CAAxB,EAAoD,CAApD,EAAuD+B,YAAvD,CAA7B;AACAjD,WAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,IAA6B,KAAKS,kBAAL,CAAwB3B,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,CAAxB,EAAoD,CAApD,EAAuDgC,cAAvD,CAA7B;AACAlD,WAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,IAA6B,KAAKS,kBAAL,CAAwB3B,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,CAAxB,EAAoD,CAApD,EAAuDiC,aAAvD,CAA7B;AACD;AAAA;;AAEOxB,oBAAkB,CAACyB,KAAD,EAAgBrD,KAAhB,EAA+ByC,IAA/B,EAA2C;AACnE,UAAMa,MAAM,GAAGD,KAAK,GAAGA,KAAK,GAAGE,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYxD,KAAZ,CAAhB,GAAqCyC,IAAI,GAAGc,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYxD,KAAZ,CAA3D;AAEA,WAAOsD,MAAP;AACD;;AAEOjB,UAAQ,CAACpC,KAAD,EAAckB,GAAd,EAAyB;AACvC,UAAMsC,GAAG,GAAGxD,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,CAAZ;AACA,UAAMuC,KAAK,GAAGzD,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,CAAd;AACA,UAAMwC,IAAI,GAAG1D,KAAK,CAACU,MAAN,CAAagB,IAAb,CAAkBR,GAAG,GAAG,CAAxB,CAAb;AAEA,WAAOO,QAAQ,CAAC,GAAG+B,GAAG,GAAG,CAAC,GAAGC,KAAK,GAAG,CAAC,GAAGC,IAAI,GAAG,CAAC,EAAlC,EAAsC,CAAtC,CAAf;AACD;;AA1ImB;;AAAtBC","names":["Encryptor","constructor","bitStuffing","bit_stuffing_1","encrypt","originalImage","secret","depth","image","clone","secretBuffer","Buffer","from","escapedSecret","escape","secretBits","buffer_to_bit_coverter_1","capacityBits","bitmap","width","height","length","Error","scanIterator","x","y","idx","setDepth","redBits","splice","join","padEnd","redNumber","parseInt","data","applyRightMostBits","greenBits","greenNumber","blueBits","blueNumber","decrypt","temp","buffer","frameEndReceived","getDepth","toString","padStart","slice","bits","split","first8bits","firstByte","concat","FE","unescapedSecret","unescape","isInteger_1","redRightMost","greenRightMost","blueRightMost","value","result","Math","pow","red","green","blue","exports"],"sources":["../src/encryptor.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}