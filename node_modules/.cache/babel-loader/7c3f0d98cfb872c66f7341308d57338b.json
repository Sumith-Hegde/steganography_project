{"ast":null,"code":"// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n'use strict';\n\nconst path = require('path');\n\nconst is = require('./is');\n\nconst sharp = require('./sharp');\n\nconst formats = new Map([['heic', 'heif'], ['heif', 'heif'], ['avif', 'avif'], ['jpeg', 'jpeg'], ['jpg', 'jpeg'], ['jpe', 'jpeg'], ['tile', 'tile'], ['dz', 'tile'], ['png', 'png'], ['raw', 'raw'], ['tiff', 'tiff'], ['tif', 'tiff'], ['webp', 'webp'], ['gif', 'gif'], ['jp2', 'jp2'], ['jpx', 'jp2'], ['j2k', 'jp2'], ['j2c', 'jp2'], ['jxl', 'jxl']]);\nconst jp2Regex = /\\.jp[2x]|j2[kc]$/i;\n\nconst errJp2Save = () => new Error('JP2 output requires libvips with support for OpenJPEG');\n\nconst bitdepthFromColourCount = colours => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, AVIF, TIFF, GIF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * The caller is responsible for ensuring directory structures and permissions exist.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toFile('output.png', (err, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toFile('output.png')\n *   .then(info => { ... })\n *   .catch(err => { ... });\n *\n * @param {string} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * When using the attention crop strategy also contains `attentionX` and `attentionY`, the focal point of the cropped region.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\n\n\nfunction toFile(fileOut, callback) {\n  let err;\n\n  if (!is.string(fileOut)) {\n    err = new Error('Missing output file path');\n  } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {\n    err = new Error('Cannot use same file for input and output');\n  } else if (jp2Regex.test(fileOut) && !this.constructor.format.jp2k.output.file) {\n    err = errJp2Save();\n  }\n\n  if (err) {\n    if (is.fn(callback)) {\n      callback(err);\n    } else {\n      return Promise.reject(err);\n    }\n  } else {\n    this.options.fileOut = fileOut;\n    return this._pipeline(callback);\n  }\n\n  return this;\n}\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, AVIF, TIFF, GIF and raw pixel data output are supported.\n *\n * Use {@link #toformat|toFormat} or one of the format-specific functions such as {@link jpeg}, {@link png} etc. to set the output format.\n *\n * If no explicit format is set, the output format will match the input image, except SVG input which becomes PNG output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toBuffer((err, data, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer()\n *   .then(data => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * sharp(input)\n *   .png()\n *   .toBuffer({ resolveWithObject: true })\n *   .then(({ data, info }) => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * const { data, info } = await sharp('my-image.jpg')\n *   // output the raw pixels\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * // create a more type safe way to work with the raw pixel data\n * // this will not copy the data, instead it will change `data`s underlying ArrayBuffer\n * // so `data` and `pixelArray` point to the same memory location\n * const pixelArray = new Uint8ClampedArray(data.buffer);\n *\n * // When you are done changing the pixelArray, sharp takes the `pixelArray` as an input\n * const { width, height, channels } = info;\n * await sharp(pixelArray, { raw: { width, height, channels } })\n *   .toFile('my-changed-image.jpg');\n *\n * @param {Object} [options]\n * @param {boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\n\n\nfunction toBuffer(options, callback) {\n  if (is.object(options)) {\n    this._setBooleanOption('resolveWithObject', options.resolveWithObject);\n  } else if (this.options.resolveWithObject) {\n    this.options.resolveWithObject = false;\n  }\n\n  this.options.fileOut = '';\n  return this._pipeline(is.fn(options) ? options : callback);\n}\n/**\n * Include all metadata (EXIF, XMP, IPTC) from the input image in the output image.\n * This will also convert to and add a web-friendly sRGB ICC profile unless a custom\n * output profile is provided.\n *\n * The default behaviour, when `withMetadata` is not used, is to convert to the device-independent\n * sRGB colour space and strip all metadata, including the removal of any ICC profile.\n *\n * EXIF metadata is unsupported for TIFF output.\n *\n * @example\n * sharp('input.jpg')\n *   .withMetadata()\n *   .toFile('output-with-metadata.jpg')\n *   .then(info => { ... });\n *\n * @example\n * // Set output EXIF metadata\n * const data = await sharp(input)\n *   .withMetadata({\n *     exif: {\n *       IFD0: {\n *         Copyright: 'The National Gallery'\n *       },\n *       IFD3: {\n *         GPSLatitudeRef: 'N',\n *         GPSLatitude: '51/1 30/1 3230/100',\n *         GPSLongitudeRef: 'W',\n *         GPSLongitude: '0/1 7/1 4366/100'\n *       }\n *     }\n *   })\n *   .toBuffer();\n *\n * @example\n * // Set output metadata to 96 DPI\n * const data = await sharp(input)\n *   .withMetadata({ density: 96 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.orientation] value between 1 and 8, used to update the EXIF `Orientation` tag.\n * @param {string} [options.icc='srgb'] Filesystem path to output ICC profile, relative to `process.cwd()`, defaults to built-in sRGB.\n * @param {Object<Object>} [options.exif={}] Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @param {number} [options.density] Number of pixels per inch (DPI).\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction withMetadata(options) {\n  this.options.withMetadata = is.bool(options) ? options : true;\n\n  if (is.object(options)) {\n    if (is.defined(options.orientation)) {\n      if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = options.orientation;\n      } else {\n        throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);\n      }\n    }\n\n    if (is.defined(options.density)) {\n      if (is.number(options.density) && options.density > 0) {\n        this.options.withMetadataDensity = options.density;\n      } else {\n        throw is.invalidParameterError('density', 'positive number', options.density);\n      }\n    }\n\n    if (is.defined(options.icc)) {\n      if (is.string(options.icc)) {\n        this.options.withMetadataIcc = options.icc;\n      } else {\n        throw is.invalidParameterError('icc', 'string filesystem path to ICC profile', options.icc);\n      }\n    }\n\n    if (is.defined(options.exif)) {\n      if (is.object(options.exif)) {\n        for (const [ifd, entries] of Object.entries(options.exif)) {\n          if (is.object(entries)) {\n            for (const [k, v] of Object.entries(entries)) {\n              if (is.string(v)) {\n                this.options.withMetadataStrs[`exif-${ifd.toLowerCase()}-${k}`] = v;\n              } else {\n                throw is.invalidParameterError(`exif.${ifd}.${k}`, 'string', v);\n              }\n            }\n          } else {\n            throw is.invalidParameterError(`exif.${ifd}`, 'object', entries);\n          }\n        }\n      } else {\n        throw is.invalidParameterError('exif', 'object', options.exif);\n      }\n    }\n  }\n\n  return this;\n}\n/**\n * Force output to a given format.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .toFormat('png')\n *   .toBuffer();\n *\n * @param {(string|Object)} format - as a string or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\n\n\nfunction toFormat(format, options) {\n  const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());\n\n  if (!actualFormat) {\n    throw is.invalidParameterError('format', `one of: ${[...formats.keys()].join(', ')}`, format);\n  }\n\n  return this[actualFormat](options);\n}\n/**\n * Use these JPEG options for output image.\n *\n * @example\n * // Convert any input to very high quality JPEG output\n * const data = await sharp(input)\n *   .jpeg({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @example\n * // Use mozjpeg to reduce output JPEG file size (slower)\n * const data = await sharp(input)\n *   .jpeg({ mozjpeg: true })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {string} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling otherwise defaults to '4:2:0' chroma subsampling\n * @param {boolean} [options.optimiseCoding=true] - optimise Huffman coding tables\n * @param {boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding\n * @param {boolean} [options.mozjpeg=false] - use mozjpeg defaults, equivalent to `{ trellisQuantisation: true, overshootDeringing: true, optimiseScans: true, quantisationTable: 3 }`\n * @param {boolean} [options.trellisQuantisation=false] - apply trellis quantisation\n * @param {boolean} [options.overshootDeringing=false] - apply overshoot deringing\n * @param {boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive\n * @param {boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {number} [options.quantisationTable=0] - quantization table to use, integer 0-8\n * @param {number} [options.quantizationTable=0] - alternative spelling of quantisationTable\n * @param {boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction jpeg(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n\n    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;\n\n    if (is.defined(optimiseCoding)) {\n      this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);\n    }\n\n    if (is.defined(options.mozjpeg)) {\n      if (is.bool(options.mozjpeg)) {\n        if (options.mozjpeg) {\n          this.options.jpegTrellisQuantisation = true;\n          this.options.jpegOvershootDeringing = true;\n          this.options.jpegOptimiseScans = true;\n          this.options.jpegProgressive = true;\n          this.options.jpegQuantisationTable = 3;\n        }\n      } else {\n        throw is.invalidParameterError('mozjpeg', 'boolean', options.mozjpeg);\n      }\n    }\n\n    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n\n    if (is.defined(trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);\n    }\n\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n\n    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n\n    if (is.defined(optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', optimiseScans);\n\n      if (optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n\n    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;\n\n    if (is.defined(quantisationTable)) {\n      if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {\n        this.options.jpegQuantisationTable = quantisationTable;\n      } else {\n        throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);\n      }\n    }\n  }\n\n  return this._updateFormatOut('jpeg', options);\n}\n/**\n * Use these PNG options for output image.\n *\n * By default, PNG output is full colour at 8 or 16 bits per pixel.\n * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.\n * Set `palette` to `true` for slower, indexed PNG output.\n *\n * @example\n * // Convert any input to full colour PNG output\n * const data = await sharp(input)\n *   .png()\n *   .toBuffer();\n *\n * @example\n * // Convert any input to indexed PNG output (slower)\n * const data = await sharp(input)\n *   .png({ palette: true })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.compressionLevel=6] - zlib compression level, 0 (fastest, largest) to 9 (slowest, smallest)\n * @param {boolean} [options.adaptiveFiltering=false] - use adaptive row filtering\n * @param {boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support\n * @param {number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, sets `palette` to `true`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest), sets `palette` to `true`\n * @param {number} [options.colours=256] - maximum number of palette entries, sets `palette` to `true`\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`, sets `palette` to `true`\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, sets `palette` to `true`\n * @param {boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction png(options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);\n      }\n    }\n\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n\n    const colours = options.colours || options.colors;\n\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.pngBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n\n    if (is.defined(options.palette)) {\n      this._setBooleanOption('pngPalette', options.palette);\n    } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {\n      this._setBooleanOption('pngPalette', true);\n    }\n\n    if (this.options.pngPalette) {\n      if (is.defined(options.quality)) {\n        if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {\n          this.options.pngQuality = options.quality;\n        } else {\n          throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);\n        }\n      }\n\n      if (is.defined(options.effort)) {\n        if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {\n          this.options.pngEffort = options.effort;\n        } else {\n          throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n        }\n      }\n\n      if (is.defined(options.dither)) {\n        if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n          this.options.pngDither = options.dither;\n        } else {\n          throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n        }\n      }\n    }\n  }\n\n  return this._updateFormatOut('png', options);\n}\n/**\n * Use these WebP options for output image.\n *\n * @example\n * // Convert any input to lossless WebP output\n * const data = await sharp(input)\n *   .webp({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Optimise the file size of an animated WebP\n * const outputWebp = await sharp(inputWebp, { animated: true })\n *   .webp({ effort: 6 })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {boolean} [options.smartSubsample=false] - use high quality chroma subsampling\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 6 (slowest)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.minSize=false] - prevent use of animation key frames to minimise file size (slow)\n * @param {boolean} [options.mixed=false] - allow mixture of lossy and lossless animation frames (slow)\n * @param {boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction webp(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.webpQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n\n    if (is.defined(options.alphaQuality)) {\n      if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {\n        this.options.webpAlphaQuality = options.alphaQuality;\n      } else {\n        throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);\n      }\n    }\n\n    if (is.defined(options.lossless)) {\n      this._setBooleanOption('webpLossless', options.lossless);\n    }\n\n    if (is.defined(options.nearLossless)) {\n      this._setBooleanOption('webpNearLossless', options.nearLossless);\n    }\n\n    if (is.defined(options.smartSubsample)) {\n      this._setBooleanOption('webpSmartSubsample', options.smartSubsample);\n    }\n\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 6)) {\n        this.options.webpEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 6', options.effort);\n      }\n    }\n\n    if (is.defined(options.minSize)) {\n      this._setBooleanOption('webpMinSize', options.minSize);\n    }\n\n    if (is.defined(options.mixed)) {\n      this._setBooleanOption('webpMixed', options.mixed);\n    }\n  }\n\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('webp', options);\n}\n/**\n * Use these GIF options for the output image.\n *\n * The first entry in the palette is reserved for transparency.\n *\n * The palette of the input image will be re-used if possible.\n *\n * @since 0.30.0\n *\n * @example\n * // Convert PNG to GIF\n * await sharp(pngBuffer)\n *   .gif()\n *   .toBuffer();\n *\n * @example\n * // Convert animated WebP to animated GIF\n * await sharp('animated.webp', { animated: true })\n *   .toFile('animated.gif');\n *\n * @example\n * // Create a 128x128, cropped, non-dithered, animated thumbnail of an animated GIF\n * const out = await sharp('in.gif', { animated: true })\n *   .resize({ width: 128, height: 128 })\n *   .gif({ dither: 0 })\n *   .toBuffer();\n *\n * @example\n * // Lossy file size reduction of animated GIF\n * await sharp('in.gif', { animated: true })\n *   .gif({ interFrameMaxError: 8 })\n *   .toFile('optim.gif');\n *\n * @param {Object} [options] - output options\n * @param {boolean} [options.reuse=true] - re-use existing palette, otherwise generate new (slow)\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.colours=256] - maximum number of palette entries, including transparency, between 2 and 256\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest)\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most)\n * @param {number} [options.interFrameMaxError=0] - maximum inter-frame error for transparency, between 0 (lossless) and 32\n * @param {number} [options.interPaletteMaxError=3] - maximum inter-palette error for palette reuse, between 0 and 256\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.force=true] - force GIF output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction gif(options) {\n  if (is.object(options)) {\n    if (is.defined(options.reuse)) {\n      this._setBooleanOption('gifReuse', options.reuse);\n    }\n\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('gifProgressive', options.progressive);\n    }\n\n    const colours = options.colours || options.colors;\n\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.gifBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n\n    if (is.defined(options.effort)) {\n      if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {\n        this.options.gifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n      }\n    }\n\n    if (is.defined(options.dither)) {\n      if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n        this.options.gifDither = options.dither;\n      } else {\n        throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n      }\n    }\n\n    if (is.defined(options.interFrameMaxError)) {\n      if (is.number(options.interFrameMaxError) && is.inRange(options.interFrameMaxError, 0, 32)) {\n        this.options.gifInterFrameMaxError = options.interFrameMaxError;\n      } else {\n        throw is.invalidParameterError('interFrameMaxError', 'number between 0.0 and 32.0', options.interFrameMaxError);\n      }\n    }\n\n    if (is.defined(options.interPaletteMaxError)) {\n      if (is.number(options.interPaletteMaxError) && is.inRange(options.interPaletteMaxError, 0, 256)) {\n        this.options.gifInterPaletteMaxError = options.interPaletteMaxError;\n      } else {\n        throw is.invalidParameterError('interPaletteMaxError', 'number between 0.0 and 256.0', options.interPaletteMaxError);\n      }\n    }\n  }\n\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('gif', options);\n}\n/* istanbul ignore next */\n\n/**\n * Use these JP2 options for output image.\n *\n * Requires libvips compiled with support for OpenJPEG.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n * // Convert any input to lossless JP2 output\n * const data = await sharp(input)\n *   .jp2({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Convert any input to very high quality JP2 output\n * const data = await sharp(input)\n *   .jp2({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @since 0.29.1\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {number} [options.tileWidth=512] - horizontal tile size\n * @param {number} [options.tileHeight=512] - vertical tile size\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction jp2(options) {\n  if (!this.constructor.format.jp2k.output.buffer) {\n    throw errJp2Save();\n  }\n\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jp2Quality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jp2Lossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {\n        this.options.jp2TileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer between 1 and 32768', options.tileWidth);\n      }\n    }\n\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {\n        this.options.jp2TileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer between 1 and 32768', options.tileHeight);\n      }\n    }\n\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jp2ChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n\n  return this._updateFormatOut('jp2', options);\n}\n/**\n * Set animation options if available.\n * @private\n *\n * @param {Object} [source] - output options\n * @param {number} [source.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number[]} [source.delay] - list of delays between animation frames (in milliseconds)\n * @param {Object} [target] - target object for valid options\n * @throws {Error} Invalid options\n */\n\n\nfunction trySetAnimationOptions(source, target) {\n  if (is.object(source) && is.defined(source.loop)) {\n    if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {\n      target.loop = source.loop;\n    } else {\n      throw is.invalidParameterError('loop', 'integer between 0 and 65535', source.loop);\n    }\n  }\n\n  if (is.object(source) && is.defined(source.delay)) {\n    // We allow singular values as well\n    if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {\n      target.delay = [source.delay];\n    } else if (Array.isArray(source.delay) && source.delay.every(is.integer) && source.delay.every(v => is.inRange(v, 0, 65535))) {\n      target.delay = source.delay;\n    } else {\n      throw is.invalidParameterError('delay', 'integer or an array of integers between 0 and 65535', source.delay);\n    }\n  }\n}\n/**\n * Use these TIFF options for output image.\n *\n * The `density` can be set in pixels/inch via {@link #withmetadata|withMetadata}\n * instead of providing `xres` and `yres` in pixels/mm.\n *\n * @example\n * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output\n * sharp('input.svg')\n *   .tiff({\n *     compression: 'lzw',\n *     bitdepth: 1\n *   })\n *   .toFile('1-bpp-output.tiff')\n *   .then(info => { ... });\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {string} [options.compression='jpeg'] - compression options: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k\n * @param {string} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float\n * @param {boolean} [options.pyramid=false] - write an image pyramid\n * @param {boolean} [options.tile=false] - write a tiled tiff\n * @param {number} [options.tileWidth=256] - horizontal tile size\n * @param {number} [options.tileHeight=256] - vertical tile size\n * @param {number} [options.xres=1.0] - horizontal resolution in pixels/mm\n * @param {number} [options.yres=1.0] - vertical resolution in pixels/mm\n * @param {string} [options.resolutionUnit='inch'] - resolution unit options: inch, cm\n * @param {number} [options.bitdepth=8] - reduce bitdepth to 1, 2 or 4 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction tiff(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.tiffQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {\n        this.options.tiffBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '1, 2, 4 or 8', options.bitdepth);\n      }\n    } // tiling\n\n\n    if (is.defined(options.tile)) {\n      this._setBooleanOption('tiffTile', options.tile);\n    }\n\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && options.tileWidth > 0) {\n        this.options.tiffTileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);\n      }\n    }\n\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && options.tileHeight > 0) {\n        this.options.tiffTileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);\n      }\n    } // pyramid\n\n\n    if (is.defined(options.pyramid)) {\n      this._setBooleanOption('tiffPyramid', options.pyramid);\n    } // resolution\n\n\n    if (is.defined(options.xres)) {\n      if (is.number(options.xres) && options.xres > 0) {\n        this.options.tiffXres = options.xres;\n      } else {\n        throw is.invalidParameterError('xres', 'number greater than zero', options.xres);\n      }\n    }\n\n    if (is.defined(options.yres)) {\n      if (is.number(options.yres) && options.yres > 0) {\n        this.options.tiffYres = options.yres;\n      } else {\n        throw is.invalidParameterError('yres', 'number greater than zero', options.yres);\n      }\n    } // compression\n\n\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['none', 'jpeg', 'deflate', 'packbits', 'ccittfax4', 'lzw', 'webp', 'zstd', 'jp2k'])) {\n        this.options.tiffCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k', options.compression);\n      }\n    } // predictor\n\n\n    if (is.defined(options.predictor)) {\n      if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n        this.options.tiffPredictor = options.predictor;\n      } else {\n        throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);\n      }\n    } // resolutionUnit\n\n\n    if (is.defined(options.resolutionUnit)) {\n      if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ['inch', 'cm'])) {\n        this.options.tiffResolutionUnit = options.resolutionUnit;\n      } else {\n        throw is.invalidParameterError('resolutionUnit', 'one of: inch, cm', options.resolutionUnit);\n      }\n    }\n  }\n\n  return this._updateFormatOut('tiff', options);\n}\n/**\n * Use these AVIF options for output image.\n *\n * Whilst it is possible to create AVIF images smaller than 16x16 pixels,\n * most web browsers do not display these properly.\n *\n * AVIF image sequences are not supported.\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ effort: 2 })\n *   .toBuffer();\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ lossless: true })\n *   .toBuffer();\n *\n * @since 0.27.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction avif(options) {\n  return this.heif({ ...options,\n    compression: 'av1'\n  });\n}\n/**\n * Use these HEIF options for output image.\n *\n * Support for patent-encumbered HEIC images using `hevc` compression requires the use of a\n * globally-installed libvips compiled with support for libheif, libde265 and x265.\n *\n * @example\n * const data = await sharp(input)\n *   .heif({ compression: 'hevc' })\n *   .toBuffer();\n *\n * @since 0.23.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {string} [options.compression='av1'] - compression format: av1, hevc\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction heif(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.heifQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.heifLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['av1', 'hevc'])) {\n        this.options.heifCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: av1, hevc', options.compression);\n      }\n    }\n\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {\n        this.options.heifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 9', options.effort);\n      }\n    }\n\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.heifChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n\n  return this._updateFormatOut('heif', options);\n}\n/**\n * Use these JPEG-XL (JXL) options for output image.\n *\n * This feature is experimental, please do not use in production systems.\n *\n * Requires libvips compiled with support for libjxl.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * Image metadata (EXIF, XMP) is unsupported.\n *\n * @since 0.31.3\n *\n * @param {Object} [options] - output options\n * @param {number} [options.distance=1.0] - maximum encoding error, between 0 (highest quality) and 15 (lowest quality)\n * @param {number} [options.quality] - calculate `distance` based on JPEG-like quality, between 1 and 100, overrides distance if specified\n * @param {number} [options.decodingTier=0] - target decode speed tier, between 0 (highest quality) and 4 (lowest quality)\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=7] - CPU effort, between 3 (fastest) and 9 (slowest)\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction jxl(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        // https://github.com/libjxl/libjxl/blob/0aeea7f180bafd6893c1db8072dcb67d2aa5b03d/tools/cjxl_main.cc#L640-L644\n        this.options.jxlDistance = options.quality >= 30 ? 0.1 + (100 - options.quality) * 0.09 : 53 / 3000 * options.quality * options.quality - 23 / 20 * options.quality + 25;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    } else if (is.defined(options.distance)) {\n      if (is.number(options.distance) && is.inRange(options.distance, 0, 15)) {\n        this.options.jxlDistance = options.distance;\n      } else {\n        throw is.invalidParameterError('distance', 'number between 0.0 and 15.0', options.distance);\n      }\n    }\n\n    if (is.defined(options.decodingTier)) {\n      if (is.integer(options.decodingTier) && is.inRange(options.decodingTier, 0, 4)) {\n        this.options.jxlDecodingTier = options.decodingTier;\n      } else {\n        throw is.invalidParameterError('decodingTier', 'integer between 0 and 4', options.decodingTier);\n      }\n    }\n\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jxlLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 3, 9)) {\n        this.options.jxlEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 3 and 9', options.effort);\n      }\n    }\n  }\n\n  return this._updateFormatOut('jxl', options);\n}\n/**\n * Force output to be raw, uncompressed pixel data.\n * Pixel ordering is left-to-right, top-to-bottom, without padding.\n * Channel ordering will be RGB or RGBA for non-greyscale colourspaces.\n *\n * @example\n * // Extract raw, unsigned 8-bit RGB pixel data from JPEG input\n * const { data, info } = await sharp('input.jpg')\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * @example\n * // Extract alpha channel as raw, unsigned 16-bit pixel data from PNG input\n * const data = await sharp('input.png')\n *   .ensureAlpha()\n *   .extractChannel(3)\n *   .toColourspace('b-w')\n *   .raw({ depth: 'ushort' })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {string} [options.depth='uchar'] - bit depth, one of: char, uchar (default), short, ushort, int, uint, float, complex, double, dpcomplex\n * @throws {Error} Invalid options\n */\n\n\nfunction raw(options) {\n  if (is.object(options)) {\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'complex', 'double', 'dpcomplex'])) {\n        this.options.rawDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex', options.depth);\n      }\n    }\n  }\n\n  return this._updateFormatOut('raw');\n}\n/**\n * Use tile-based deep zoom (image pyramid) output.\n *\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * The container will be set to `zip` when the output is a Buffer or Stream, otherwise it will default to `fs`.\n *\n * Requires libvips compiled with support for libgsf.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @example\n * const zipFileWithTiles = await sharp(input)\n *   .tile({ basename: \"tiles\" })\n *   .toBuffer();\n *\n * @example\n * const iiififier = sharp().tile({ layout: \"iiif\" });\n * readableStream\n *   .pipe(iiififier)\n *   .pipe(writeableStream);\n *\n * @param {Object} [options]\n * @param {number} [options.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {number} [options.angle=0] tile angle of rotation, must be a multiple of 90.\n * @param {string|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.\n * @param {string} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.\n * @param {number} [options.skipBlanks=-1] threshold to skip tile generation, a value 0 - 255 for 8-bit images or 0 - 65535 for 16-bit images\n * @param {string} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {string} [options.layout='dz'] filesystem layout, possible values are `dz`, `iiif`, `iiif3`, `zoomify` or `google`.\n * @param {boolean} [options.centre=false] centre image in tile.\n * @param {boolean} [options.center=false] alternative spelling of centre.\n * @param {string} [options.id='https://example.com/iiif'] when `layout` is `iiif`/`iiif3`, sets the `@id`/`id` attribute of `info.json`\n * @param {string} [options.basename] the name of the directory within the zip file when container is `zip`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction tile(options) {\n  if (is.object(options)) {\n    // Size of square tiles, in pixels\n    if (is.defined(options.size)) {\n      if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {\n        this.options.tileSize = options.size;\n      } else {\n        throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);\n      }\n    } // Overlap of tiles, in pixels\n\n\n    if (is.defined(options.overlap)) {\n      if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {\n        if (options.overlap > this.options.tileSize) {\n          throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);\n        }\n\n        this.options.tileOverlap = options.overlap;\n      } else {\n        throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);\n      }\n    } // Container\n\n\n    if (is.defined(options.container)) {\n      if (is.string(options.container) && is.inArray(options.container, ['fs', 'zip'])) {\n        this.options.tileContainer = options.container;\n      } else {\n        throw is.invalidParameterError('container', 'one of: fs, zip', options.container);\n      }\n    } // Layout\n\n\n    if (is.defined(options.layout)) {\n      if (is.string(options.layout) && is.inArray(options.layout, ['dz', 'google', 'iiif', 'iiif3', 'zoomify'])) {\n        this.options.tileLayout = options.layout;\n      } else {\n        throw is.invalidParameterError('layout', 'one of: dz, google, iiif, iiif3, zoomify', options.layout);\n      }\n    } // Angle of rotation,\n\n\n    if (is.defined(options.angle)) {\n      if (is.integer(options.angle) && !(options.angle % 90)) {\n        this.options.tileAngle = options.angle;\n      } else {\n        throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);\n      }\n    } // Background colour\n\n\n    this._setBackgroundColourOption('tileBackground', options.background); // Depth of tiles\n\n\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['onepixel', 'onetile', 'one'])) {\n        this.options.tileDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);\n      }\n    } // Threshold to skip blank tiles\n\n\n    if (is.defined(options.skipBlanks)) {\n      if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {\n        this.options.tileSkipBlanks = options.skipBlanks;\n      } else {\n        throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);\n      }\n    } else if (is.defined(options.layout) && options.layout === 'google') {\n      this.options.tileSkipBlanks = 5;\n    } // Center image in tile\n\n\n    const centre = is.bool(options.center) ? options.center : options.centre;\n\n    if (is.defined(centre)) {\n      this._setBooleanOption('tileCentre', centre);\n    } // @id attribute for IIIF layout\n\n\n    if (is.defined(options.id)) {\n      if (is.string(options.id)) {\n        this.options.tileId = options.id;\n      } else {\n        throw is.invalidParameterError('id', 'string', options.id);\n      }\n    } // Basename for zip container\n\n\n    if (is.defined(options.basename)) {\n      if (is.string(options.basename)) {\n        this.options.tileBasename = options.basename;\n      } else {\n        throw is.invalidParameterError('basename', 'string', options.basename);\n      }\n    }\n  } // Format\n\n\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);\n  }\n\n  return this._updateFormatOut('dz');\n}\n/**\n * Set a timeout for processing, in seconds.\n * Use a value of zero to continue processing indefinitely, the default behaviour.\n *\n * The clock starts when libvips opens an input image for processing.\n * Time spent waiting for a libuv thread to become available is not included.\n *\n * @example\n * // Ensure processing takes no longer than 3 seconds\n * try {\n *   const data = await sharp(input)\n *     .blur(1000)\n *     .timeout({ seconds: 3 })\n *     .toBuffer();\n * } catch (err) {\n *   if (err.message.includes('timeout')) { ... }\n * }\n *\n * @since 0.29.2\n *\n * @param {Object} options\n * @param {number} options.seconds - Number of seconds after which processing will be stopped\n * @returns {Sharp}\n */\n\n\nfunction timeout(options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'object', options);\n  }\n\n  if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {\n    this.options.timeoutSeconds = options.seconds;\n  } else {\n    throw is.invalidParameterError('seconds', 'integer between 0 and 3600', options.seconds);\n  }\n\n  return this;\n}\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {string} formatOut\n * @param {Object} [options]\n * @param {boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\n\n\nfunction _updateFormatOut(formatOut, options) {\n  if (!(is.object(options) && options.force === false)) {\n    this.options.formatOut = formatOut;\n  }\n\n  return this;\n}\n/**\n * Update a boolean attribute of the this.options Object.\n * @private\n * @param {string} key\n * @param {boolean} val\n * @throws {Error} Invalid key\n */\n\n\nfunction _setBooleanOption(key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw is.invalidParameterError(key, 'boolean', val);\n  }\n}\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\n\n\nfunction _read() {\n  /* istanbul ignore else */\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n\n    this._pipeline();\n  }\n}\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\n\n\nfunction _pipeline(callback) {\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', () => {\n        this._flattenBufferIn();\n\n        sharp.pipeline(this.options, callback);\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, callback);\n    }\n\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      this.once('finish', () => {\n        this._flattenBufferIn();\n\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this.emit('info', info);\n            this.push(data);\n          }\n\n          this.push(null);\n          this.on('end', () => this.emit('close'));\n        });\n      });\n\n      if (this.streamInFinished) {\n        this.emit('finish');\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          this.emit('error', err);\n        } else {\n          this.emit('info', info);\n          this.push(data);\n        }\n\n        this.push(null);\n        this.on('end', () => this.emit('close'));\n      });\n    }\n\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise((resolve, reject) => {\n        this.once('finish', () => {\n          this._flattenBufferIn();\n\n          sharp.pipeline(this.options, (err, data, info) => {\n            if (err) {\n              reject(err);\n            } else {\n              if (this.options.resolveWithObject) {\n                resolve({\n                  data,\n                  info\n                });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise((resolve, reject) => {\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            reject(err);\n          } else {\n            if (this.options.resolveWithObject) {\n              resolve({\n                data: data,\n                info: info\n              });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @private\n */\n\n\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    toFile,\n    toBuffer,\n    withMetadata,\n    toFormat,\n    jpeg,\n    jp2,\n    png,\n    webp,\n    tiff,\n    avif,\n    heif,\n    jxl,\n    gif,\n    raw,\n    tile,\n    timeout,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  });\n};","map":{"version":3,"sources":["D:/VS_Code/VS_Code_general_Workspace/finalYearProject/chatApp/node_modules/sharp/lib/output.js"],"names":["path","require","is","sharp","formats","Map","jp2Regex","errJp2Save","Error","bitdepthFromColourCount","colours","Math","clz32","ceil","log2","toFile","fileOut","callback","err","string","options","input","file","resolve","test","constructor","format","jp2k","output","fn","Promise","reject","_pipeline","toBuffer","object","_setBooleanOption","resolveWithObject","withMetadata","bool","defined","orientation","integer","inRange","withMetadataOrientation","invalidParameterError","density","number","withMetadataDensity","icc","withMetadataIcc","exif","ifd","entries","Object","k","v","withMetadataStrs","toLowerCase","toFormat","actualFormat","get","id","keys","join","jpeg","quality","jpegQuality","progressive","chromaSubsampling","inArray","jpegChromaSubsampling","optimiseCoding","optimizeCoding","mozjpeg","jpegTrellisQuantisation","jpegOvershootDeringing","jpegOptimiseScans","jpegProgressive","jpegQuantisationTable","trellisQuantisation","trellisQuantization","overshootDeringing","optimiseScans","optimizeScans","quantisationTable","quantizationTable","_updateFormatOut","png","compressionLevel","pngCompressionLevel","adaptiveFiltering","colors","pngBitdepth","palette","effort","dither","some","pngPalette","pngQuality","pngEffort","pngDither","webp","webpQuality","alphaQuality","webpAlphaQuality","lossless","nearLossless","smartSubsample","webpEffort","minSize","mixed","trySetAnimationOptions","gif","reuse","gifBitdepth","gifEffort","gifDither","interFrameMaxError","gifInterFrameMaxError","interPaletteMaxError","gifInterPaletteMaxError","jp2","buffer","jp2Quality","jp2Lossless","tileWidth","jp2TileWidth","tileHeight","jp2TileHeight","jp2ChromaSubsampling","source","target","loop","delay","Array","isArray","every","tiff","tiffQuality","bitdepth","tiffBitdepth","tile","tiffTileWidth","tiffTileHeight","pyramid","xres","tiffXres","yres","tiffYres","compression","tiffCompression","predictor","tiffPredictor","resolutionUnit","tiffResolutionUnit","avif","heif","heifQuality","heifLossless","heifCompression","heifEffort","heifChromaSubsampling","jxl","jxlDistance","distance","decodingTier","jxlDecodingTier","jxlLossless","jxlEffort","raw","depth","rawDepth","size","tileSize","overlap","tileOverlap","container","tileContainer","layout","tileLayout","angle","tileAngle","_setBackgroundColourOption","background","tileDepth","skipBlanks","tileSkipBlanks","centre","center","tileId","basename","tileBasename","formatOut","tileFormat","timeout","plainObject","seconds","timeoutSeconds","force","key","val","_read","streamOut","_isStreamInput","on","_flattenBufferIn","pipeline","once","data","info","emit","push","streamInFinished","module","exports","Sharp","assign","prototype"],"mappings":"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","sourcesContent":["// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst path = require('path');\nconst is = require('./is');\nconst sharp = require('./sharp');\n\nconst formats = new Map([\n  ['heic', 'heif'],\n  ['heif', 'heif'],\n  ['avif', 'avif'],\n  ['jpeg', 'jpeg'],\n  ['jpg', 'jpeg'],\n  ['jpe', 'jpeg'],\n  ['tile', 'tile'],\n  ['dz', 'tile'],\n  ['png', 'png'],\n  ['raw', 'raw'],\n  ['tiff', 'tiff'],\n  ['tif', 'tiff'],\n  ['webp', 'webp'],\n  ['gif', 'gif'],\n  ['jp2', 'jp2'],\n  ['jpx', 'jp2'],\n  ['j2k', 'jp2'],\n  ['j2c', 'jp2'],\n  ['jxl', 'jxl']\n]);\n\nconst jp2Regex = /\\.jp[2x]|j2[kc]$/i;\n\nconst errJp2Save = () => new Error('JP2 output requires libvips with support for OpenJPEG');\n\nconst bitdepthFromColourCount = (colours) => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));\n\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, AVIF, TIFF, GIF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * The caller is responsible for ensuring directory structures and permissions exist.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toFile('output.png', (err, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toFile('output.png')\n *   .then(info => { ... })\n *   .catch(err => { ... });\n *\n * @param {string} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * When using the attention crop strategy also contains `attentionX` and `attentionY`, the focal point of the cropped region.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\nfunction toFile (fileOut, callback) {\n  let err;\n  if (!is.string(fileOut)) {\n    err = new Error('Missing output file path');\n  } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {\n    err = new Error('Cannot use same file for input and output');\n  } else if (jp2Regex.test(fileOut) && !this.constructor.format.jp2k.output.file) {\n    err = errJp2Save();\n  }\n  if (err) {\n    if (is.fn(callback)) {\n      callback(err);\n    } else {\n      return Promise.reject(err);\n    }\n  } else {\n    this.options.fileOut = fileOut;\n    return this._pipeline(callback);\n  }\n  return this;\n}\n\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, AVIF, TIFF, GIF and raw pixel data output are supported.\n *\n * Use {@link #toformat|toFormat} or one of the format-specific functions such as {@link jpeg}, {@link png} etc. to set the output format.\n *\n * If no explicit format is set, the output format will match the input image, except SVG input which becomes PNG output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toBuffer((err, data, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer()\n *   .then(data => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * sharp(input)\n *   .png()\n *   .toBuffer({ resolveWithObject: true })\n *   .then(({ data, info }) => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * const { data, info } = await sharp('my-image.jpg')\n *   // output the raw pixels\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * // create a more type safe way to work with the raw pixel data\n * // this will not copy the data, instead it will change `data`s underlying ArrayBuffer\n * // so `data` and `pixelArray` point to the same memory location\n * const pixelArray = new Uint8ClampedArray(data.buffer);\n *\n * // When you are done changing the pixelArray, sharp takes the `pixelArray` as an input\n * const { width, height, channels } = info;\n * await sharp(pixelArray, { raw: { width, height, channels } })\n *   .toFile('my-changed-image.jpg');\n *\n * @param {Object} [options]\n * @param {boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\nfunction toBuffer (options, callback) {\n  if (is.object(options)) {\n    this._setBooleanOption('resolveWithObject', options.resolveWithObject);\n  } else if (this.options.resolveWithObject) {\n    this.options.resolveWithObject = false;\n  }\n  this.options.fileOut = '';\n  return this._pipeline(is.fn(options) ? options : callback);\n}\n\n/**\n * Include all metadata (EXIF, XMP, IPTC) from the input image in the output image.\n * This will also convert to and add a web-friendly sRGB ICC profile unless a custom\n * output profile is provided.\n *\n * The default behaviour, when `withMetadata` is not used, is to convert to the device-independent\n * sRGB colour space and strip all metadata, including the removal of any ICC profile.\n *\n * EXIF metadata is unsupported for TIFF output.\n *\n * @example\n * sharp('input.jpg')\n *   .withMetadata()\n *   .toFile('output-with-metadata.jpg')\n *   .then(info => { ... });\n *\n * @example\n * // Set output EXIF metadata\n * const data = await sharp(input)\n *   .withMetadata({\n *     exif: {\n *       IFD0: {\n *         Copyright: 'The National Gallery'\n *       },\n *       IFD3: {\n *         GPSLatitudeRef: 'N',\n *         GPSLatitude: '51/1 30/1 3230/100',\n *         GPSLongitudeRef: 'W',\n *         GPSLongitude: '0/1 7/1 4366/100'\n *       }\n *     }\n *   })\n *   .toBuffer();\n *\n * @example\n * // Set output metadata to 96 DPI\n * const data = await sharp(input)\n *   .withMetadata({ density: 96 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.orientation] value between 1 and 8, used to update the EXIF `Orientation` tag.\n * @param {string} [options.icc='srgb'] Filesystem path to output ICC profile, relative to `process.cwd()`, defaults to built-in sRGB.\n * @param {Object<Object>} [options.exif={}] Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @param {number} [options.density] Number of pixels per inch (DPI).\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withMetadata (options) {\n  this.options.withMetadata = is.bool(options) ? options : true;\n  if (is.object(options)) {\n    if (is.defined(options.orientation)) {\n      if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = options.orientation;\n      } else {\n        throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);\n      }\n    }\n    if (is.defined(options.density)) {\n      if (is.number(options.density) && options.density > 0) {\n        this.options.withMetadataDensity = options.density;\n      } else {\n        throw is.invalidParameterError('density', 'positive number', options.density);\n      }\n    }\n    if (is.defined(options.icc)) {\n      if (is.string(options.icc)) {\n        this.options.withMetadataIcc = options.icc;\n      } else {\n        throw is.invalidParameterError('icc', 'string filesystem path to ICC profile', options.icc);\n      }\n    }\n    if (is.defined(options.exif)) {\n      if (is.object(options.exif)) {\n        for (const [ifd, entries] of Object.entries(options.exif)) {\n          if (is.object(entries)) {\n            for (const [k, v] of Object.entries(entries)) {\n              if (is.string(v)) {\n                this.options.withMetadataStrs[`exif-${ifd.toLowerCase()}-${k}`] = v;\n              } else {\n                throw is.invalidParameterError(`exif.${ifd}.${k}`, 'string', v);\n              }\n            }\n          } else {\n            throw is.invalidParameterError(`exif.${ifd}`, 'object', entries);\n          }\n        }\n      } else {\n        throw is.invalidParameterError('exif', 'object', options.exif);\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Force output to a given format.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .toFormat('png')\n *   .toBuffer();\n *\n * @param {(string|Object)} format - as a string or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\nfunction toFormat (format, options) {\n  const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());\n  if (!actualFormat) {\n    throw is.invalidParameterError('format', `one of: ${[...formats.keys()].join(', ')}`, format);\n  }\n  return this[actualFormat](options);\n}\n\n/**\n * Use these JPEG options for output image.\n *\n * @example\n * // Convert any input to very high quality JPEG output\n * const data = await sharp(input)\n *   .jpeg({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @example\n * // Use mozjpeg to reduce output JPEG file size (slower)\n * const data = await sharp(input)\n *   .jpeg({ mozjpeg: true })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {string} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling otherwise defaults to '4:2:0' chroma subsampling\n * @param {boolean} [options.optimiseCoding=true] - optimise Huffman coding tables\n * @param {boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding\n * @param {boolean} [options.mozjpeg=false] - use mozjpeg defaults, equivalent to `{ trellisQuantisation: true, overshootDeringing: true, optimiseScans: true, quantisationTable: 3 }`\n * @param {boolean} [options.trellisQuantisation=false] - apply trellis quantisation\n * @param {boolean} [options.overshootDeringing=false] - apply overshoot deringing\n * @param {boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive\n * @param {boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {number} [options.quantisationTable=0] - quantization table to use, integer 0-8\n * @param {number} [options.quantizationTable=0] - alternative spelling of quantisationTable\n * @param {boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jpeg (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;\n    if (is.defined(optimiseCoding)) {\n      this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);\n    }\n    if (is.defined(options.mozjpeg)) {\n      if (is.bool(options.mozjpeg)) {\n        if (options.mozjpeg) {\n          this.options.jpegTrellisQuantisation = true;\n          this.options.jpegOvershootDeringing = true;\n          this.options.jpegOptimiseScans = true;\n          this.options.jpegProgressive = true;\n          this.options.jpegQuantisationTable = 3;\n        }\n      } else {\n        throw is.invalidParameterError('mozjpeg', 'boolean', options.mozjpeg);\n      }\n    }\n    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n    if (is.defined(trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);\n    }\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n    if (is.defined(optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', optimiseScans);\n      if (optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;\n    if (is.defined(quantisationTable)) {\n      if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {\n        this.options.jpegQuantisationTable = quantisationTable;\n      } else {\n        throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);\n      }\n    }\n  }\n  return this._updateFormatOut('jpeg', options);\n}\n\n/**\n * Use these PNG options for output image.\n *\n * By default, PNG output is full colour at 8 or 16 bits per pixel.\n * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.\n * Set `palette` to `true` for slower, indexed PNG output.\n *\n * @example\n * // Convert any input to full colour PNG output\n * const data = await sharp(input)\n *   .png()\n *   .toBuffer();\n *\n * @example\n * // Convert any input to indexed PNG output (slower)\n * const data = await sharp(input)\n *   .png({ palette: true })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.compressionLevel=6] - zlib compression level, 0 (fastest, largest) to 9 (slowest, smallest)\n * @param {boolean} [options.adaptiveFiltering=false] - use adaptive row filtering\n * @param {boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support\n * @param {number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, sets `palette` to `true`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest), sets `palette` to `true`\n * @param {number} [options.colours=256] - maximum number of palette entries, sets `palette` to `true`\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`, sets `palette` to `true`\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, sets `palette` to `true`\n * @param {boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction png (options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);\n      }\n    }\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.pngBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.palette)) {\n      this._setBooleanOption('pngPalette', options.palette);\n    } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {\n      this._setBooleanOption('pngPalette', true);\n    }\n    if (this.options.pngPalette) {\n      if (is.defined(options.quality)) {\n        if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {\n          this.options.pngQuality = options.quality;\n        } else {\n          throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);\n        }\n      }\n      if (is.defined(options.effort)) {\n        if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {\n          this.options.pngEffort = options.effort;\n        } else {\n          throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n        }\n      }\n      if (is.defined(options.dither)) {\n        if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n          this.options.pngDither = options.dither;\n        } else {\n          throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n        }\n      }\n    }\n  }\n  return this._updateFormatOut('png', options);\n}\n\n/**\n * Use these WebP options for output image.\n *\n * @example\n * // Convert any input to lossless WebP output\n * const data = await sharp(input)\n *   .webp({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Optimise the file size of an animated WebP\n * const outputWebp = await sharp(inputWebp, { animated: true })\n *   .webp({ effort: 6 })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {boolean} [options.smartSubsample=false] - use high quality chroma subsampling\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 6 (slowest)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.minSize=false] - prevent use of animation key frames to minimise file size (slow)\n * @param {boolean} [options.mixed=false] - allow mixture of lossy and lossless animation frames (slow)\n * @param {boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction webp (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.webpQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.alphaQuality)) {\n      if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {\n        this.options.webpAlphaQuality = options.alphaQuality;\n      } else {\n        throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      this._setBooleanOption('webpLossless', options.lossless);\n    }\n    if (is.defined(options.nearLossless)) {\n      this._setBooleanOption('webpNearLossless', options.nearLossless);\n    }\n    if (is.defined(options.smartSubsample)) {\n      this._setBooleanOption('webpSmartSubsample', options.smartSubsample);\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 6)) {\n        this.options.webpEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 6', options.effort);\n      }\n    }\n    if (is.defined(options.minSize)) {\n      this._setBooleanOption('webpMinSize', options.minSize);\n    }\n    if (is.defined(options.mixed)) {\n      this._setBooleanOption('webpMixed', options.mixed);\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('webp', options);\n}\n\n/**\n * Use these GIF options for the output image.\n *\n * The first entry in the palette is reserved for transparency.\n *\n * The palette of the input image will be re-used if possible.\n *\n * @since 0.30.0\n *\n * @example\n * // Convert PNG to GIF\n * await sharp(pngBuffer)\n *   .gif()\n *   .toBuffer();\n *\n * @example\n * // Convert animated WebP to animated GIF\n * await sharp('animated.webp', { animated: true })\n *   .toFile('animated.gif');\n *\n * @example\n * // Create a 128x128, cropped, non-dithered, animated thumbnail of an animated GIF\n * const out = await sharp('in.gif', { animated: true })\n *   .resize({ width: 128, height: 128 })\n *   .gif({ dither: 0 })\n *   .toBuffer();\n *\n * @example\n * // Lossy file size reduction of animated GIF\n * await sharp('in.gif', { animated: true })\n *   .gif({ interFrameMaxError: 8 })\n *   .toFile('optim.gif');\n *\n * @param {Object} [options] - output options\n * @param {boolean} [options.reuse=true] - re-use existing palette, otherwise generate new (slow)\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.colours=256] - maximum number of palette entries, including transparency, between 2 and 256\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest)\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most)\n * @param {number} [options.interFrameMaxError=0] - maximum inter-frame error for transparency, between 0 (lossless) and 32\n * @param {number} [options.interPaletteMaxError=3] - maximum inter-palette error for palette reuse, between 0 and 256\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.force=true] - force GIF output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction gif (options) {\n  if (is.object(options)) {\n    if (is.defined(options.reuse)) {\n      this._setBooleanOption('gifReuse', options.reuse);\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('gifProgressive', options.progressive);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.gifBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {\n        this.options.gifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n      }\n    }\n    if (is.defined(options.dither)) {\n      if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n        this.options.gifDither = options.dither;\n      } else {\n        throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n      }\n    }\n    if (is.defined(options.interFrameMaxError)) {\n      if (is.number(options.interFrameMaxError) && is.inRange(options.interFrameMaxError, 0, 32)) {\n        this.options.gifInterFrameMaxError = options.interFrameMaxError;\n      } else {\n        throw is.invalidParameterError('interFrameMaxError', 'number between 0.0 and 32.0', options.interFrameMaxError);\n      }\n    }\n    if (is.defined(options.interPaletteMaxError)) {\n      if (is.number(options.interPaletteMaxError) && is.inRange(options.interPaletteMaxError, 0, 256)) {\n        this.options.gifInterPaletteMaxError = options.interPaletteMaxError;\n      } else {\n        throw is.invalidParameterError('interPaletteMaxError', 'number between 0.0 and 256.0', options.interPaletteMaxError);\n      }\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('gif', options);\n}\n\n/* istanbul ignore next */\n/**\n * Use these JP2 options for output image.\n *\n * Requires libvips compiled with support for OpenJPEG.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n * // Convert any input to lossless JP2 output\n * const data = await sharp(input)\n *   .jp2({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Convert any input to very high quality JP2 output\n * const data = await sharp(input)\n *   .jp2({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @since 0.29.1\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {number} [options.tileWidth=512] - horizontal tile size\n * @param {number} [options.tileHeight=512] - vertical tile size\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jp2 (options) {\n  if (!this.constructor.format.jp2k.output.buffer) {\n    throw errJp2Save();\n  }\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jp2Quality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jp2Lossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {\n        this.options.jp2TileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer between 1 and 32768', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {\n        this.options.jp2TileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer between 1 and 32768', options.tileHeight);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jp2ChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('jp2', options);\n}\n\n/**\n * Set animation options if available.\n * @private\n *\n * @param {Object} [source] - output options\n * @param {number} [source.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number[]} [source.delay] - list of delays between animation frames (in milliseconds)\n * @param {Object} [target] - target object for valid options\n * @throws {Error} Invalid options\n */\nfunction trySetAnimationOptions (source, target) {\n  if (is.object(source) && is.defined(source.loop)) {\n    if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {\n      target.loop = source.loop;\n    } else {\n      throw is.invalidParameterError('loop', 'integer between 0 and 65535', source.loop);\n    }\n  }\n  if (is.object(source) && is.defined(source.delay)) {\n    // We allow singular values as well\n    if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {\n      target.delay = [source.delay];\n    } else if (\n      Array.isArray(source.delay) &&\n      source.delay.every(is.integer) &&\n      source.delay.every(v => is.inRange(v, 0, 65535))) {\n      target.delay = source.delay;\n    } else {\n      throw is.invalidParameterError('delay', 'integer or an array of integers between 0 and 65535', source.delay);\n    }\n  }\n}\n\n/**\n * Use these TIFF options for output image.\n *\n * The `density` can be set in pixels/inch via {@link #withmetadata|withMetadata}\n * instead of providing `xres` and `yres` in pixels/mm.\n *\n * @example\n * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output\n * sharp('input.svg')\n *   .tiff({\n *     compression: 'lzw',\n *     bitdepth: 1\n *   })\n *   .toFile('1-bpp-output.tiff')\n *   .then(info => { ... });\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {string} [options.compression='jpeg'] - compression options: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k\n * @param {string} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float\n * @param {boolean} [options.pyramid=false] - write an image pyramid\n * @param {boolean} [options.tile=false] - write a tiled tiff\n * @param {number} [options.tileWidth=256] - horizontal tile size\n * @param {number} [options.tileHeight=256] - vertical tile size\n * @param {number} [options.xres=1.0] - horizontal resolution in pixels/mm\n * @param {number} [options.yres=1.0] - vertical resolution in pixels/mm\n * @param {string} [options.resolutionUnit='inch'] - resolution unit options: inch, cm\n * @param {number} [options.bitdepth=8] - reduce bitdepth to 1, 2 or 4 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction tiff (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.tiffQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {\n        this.options.tiffBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '1, 2, 4 or 8', options.bitdepth);\n      }\n    }\n    // tiling\n    if (is.defined(options.tile)) {\n      this._setBooleanOption('tiffTile', options.tile);\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && options.tileWidth > 0) {\n        this.options.tiffTileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && options.tileHeight > 0) {\n        this.options.tiffTileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);\n      }\n    }\n    // pyramid\n    if (is.defined(options.pyramid)) {\n      this._setBooleanOption('tiffPyramid', options.pyramid);\n    }\n    // resolution\n    if (is.defined(options.xres)) {\n      if (is.number(options.xres) && options.xres > 0) {\n        this.options.tiffXres = options.xres;\n      } else {\n        throw is.invalidParameterError('xres', 'number greater than zero', options.xres);\n      }\n    }\n    if (is.defined(options.yres)) {\n      if (is.number(options.yres) && options.yres > 0) {\n        this.options.tiffYres = options.yres;\n      } else {\n        throw is.invalidParameterError('yres', 'number greater than zero', options.yres);\n      }\n    }\n    // compression\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['none', 'jpeg', 'deflate', 'packbits', 'ccittfax4', 'lzw', 'webp', 'zstd', 'jp2k'])) {\n        this.options.tiffCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k', options.compression);\n      }\n    }\n    // predictor\n    if (is.defined(options.predictor)) {\n      if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n        this.options.tiffPredictor = options.predictor;\n      } else {\n        throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);\n      }\n    }\n    // resolutionUnit\n    if (is.defined(options.resolutionUnit)) {\n      if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ['inch', 'cm'])) {\n        this.options.tiffResolutionUnit = options.resolutionUnit;\n      } else {\n        throw is.invalidParameterError('resolutionUnit', 'one of: inch, cm', options.resolutionUnit);\n      }\n    }\n  }\n  return this._updateFormatOut('tiff', options);\n}\n\n/**\n * Use these AVIF options for output image.\n *\n * Whilst it is possible to create AVIF images smaller than 16x16 pixels,\n * most web browsers do not display these properly.\n *\n * AVIF image sequences are not supported.\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ effort: 2 })\n *   .toBuffer();\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ lossless: true })\n *   .toBuffer();\n *\n * @since 0.27.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction avif (options) {\n  return this.heif({ ...options, compression: 'av1' });\n}\n\n/**\n * Use these HEIF options for output image.\n *\n * Support for patent-encumbered HEIC images using `hevc` compression requires the use of a\n * globally-installed libvips compiled with support for libheif, libde265 and x265.\n *\n * @example\n * const data = await sharp(input)\n *   .heif({ compression: 'hevc' })\n *   .toBuffer();\n *\n * @since 0.23.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {string} [options.compression='av1'] - compression format: av1, hevc\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction heif (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.heifQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.heifLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['av1', 'hevc'])) {\n        this.options.heifCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: av1, hevc', options.compression);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {\n        this.options.heifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 9', options.effort);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.heifChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('heif', options);\n}\n\n/**\n * Use these JPEG-XL (JXL) options for output image.\n *\n * This feature is experimental, please do not use in production systems.\n *\n * Requires libvips compiled with support for libjxl.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * Image metadata (EXIF, XMP) is unsupported.\n *\n * @since 0.31.3\n *\n * @param {Object} [options] - output options\n * @param {number} [options.distance=1.0] - maximum encoding error, between 0 (highest quality) and 15 (lowest quality)\n * @param {number} [options.quality] - calculate `distance` based on JPEG-like quality, between 1 and 100, overrides distance if specified\n * @param {number} [options.decodingTier=0] - target decode speed tier, between 0 (highest quality) and 4 (lowest quality)\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=7] - CPU effort, between 3 (fastest) and 9 (slowest)\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jxl (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        // https://github.com/libjxl/libjxl/blob/0aeea7f180bafd6893c1db8072dcb67d2aa5b03d/tools/cjxl_main.cc#L640-L644\n        this.options.jxlDistance = options.quality >= 30\n          ? 0.1 + (100 - options.quality) * 0.09\n          : 53 / 3000 * options.quality * options.quality - 23 / 20 * options.quality + 25;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    } else if (is.defined(options.distance)) {\n      if (is.number(options.distance) && is.inRange(options.distance, 0, 15)) {\n        this.options.jxlDistance = options.distance;\n      } else {\n        throw is.invalidParameterError('distance', 'number between 0.0 and 15.0', options.distance);\n      }\n    }\n    if (is.defined(options.decodingTier)) {\n      if (is.integer(options.decodingTier) && is.inRange(options.decodingTier, 0, 4)) {\n        this.options.jxlDecodingTier = options.decodingTier;\n      } else {\n        throw is.invalidParameterError('decodingTier', 'integer between 0 and 4', options.decodingTier);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jxlLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 3, 9)) {\n        this.options.jxlEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 3 and 9', options.effort);\n      }\n    }\n  }\n  return this._updateFormatOut('jxl', options);\n}\n\n/**\n * Force output to be raw, uncompressed pixel data.\n * Pixel ordering is left-to-right, top-to-bottom, without padding.\n * Channel ordering will be RGB or RGBA for non-greyscale colourspaces.\n *\n * @example\n * // Extract raw, unsigned 8-bit RGB pixel data from JPEG input\n * const { data, info } = await sharp('input.jpg')\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * @example\n * // Extract alpha channel as raw, unsigned 16-bit pixel data from PNG input\n * const data = await sharp('input.png')\n *   .ensureAlpha()\n *   .extractChannel(3)\n *   .toColourspace('b-w')\n *   .raw({ depth: 'ushort' })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {string} [options.depth='uchar'] - bit depth, one of: char, uchar (default), short, ushort, int, uint, float, complex, double, dpcomplex\n * @throws {Error} Invalid options\n */\nfunction raw (options) {\n  if (is.object(options)) {\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth,\n        ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'complex', 'double', 'dpcomplex']\n      )) {\n        this.options.rawDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex', options.depth);\n      }\n    }\n  }\n  return this._updateFormatOut('raw');\n}\n\n/**\n * Use tile-based deep zoom (image pyramid) output.\n *\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * The container will be set to `zip` when the output is a Buffer or Stream, otherwise it will default to `fs`.\n *\n * Requires libvips compiled with support for libgsf.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @example\n * const zipFileWithTiles = await sharp(input)\n *   .tile({ basename: \"tiles\" })\n *   .toBuffer();\n *\n * @example\n * const iiififier = sharp().tile({ layout: \"iiif\" });\n * readableStream\n *   .pipe(iiififier)\n *   .pipe(writeableStream);\n *\n * @param {Object} [options]\n * @param {number} [options.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {number} [options.angle=0] tile angle of rotation, must be a multiple of 90.\n * @param {string|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.\n * @param {string} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.\n * @param {number} [options.skipBlanks=-1] threshold to skip tile generation, a value 0 - 255 for 8-bit images or 0 - 65535 for 16-bit images\n * @param {string} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {string} [options.layout='dz'] filesystem layout, possible values are `dz`, `iiif`, `iiif3`, `zoomify` or `google`.\n * @param {boolean} [options.centre=false] centre image in tile.\n * @param {boolean} [options.center=false] alternative spelling of centre.\n * @param {string} [options.id='https://example.com/iiif'] when `layout` is `iiif`/`iiif3`, sets the `@id`/`id` attribute of `info.json`\n * @param {string} [options.basename] the name of the directory within the zip file when container is `zip`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction tile (options) {\n  if (is.object(options)) {\n    // Size of square tiles, in pixels\n    if (is.defined(options.size)) {\n      if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {\n        this.options.tileSize = options.size;\n      } else {\n        throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);\n      }\n    }\n    // Overlap of tiles, in pixels\n    if (is.defined(options.overlap)) {\n      if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {\n        if (options.overlap > this.options.tileSize) {\n          throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);\n        }\n        this.options.tileOverlap = options.overlap;\n      } else {\n        throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);\n      }\n    }\n    // Container\n    if (is.defined(options.container)) {\n      if (is.string(options.container) && is.inArray(options.container, ['fs', 'zip'])) {\n        this.options.tileContainer = options.container;\n      } else {\n        throw is.invalidParameterError('container', 'one of: fs, zip', options.container);\n      }\n    }\n    // Layout\n    if (is.defined(options.layout)) {\n      if (is.string(options.layout) && is.inArray(options.layout, ['dz', 'google', 'iiif', 'iiif3', 'zoomify'])) {\n        this.options.tileLayout = options.layout;\n      } else {\n        throw is.invalidParameterError('layout', 'one of: dz, google, iiif, iiif3, zoomify', options.layout);\n      }\n    }\n    // Angle of rotation,\n    if (is.defined(options.angle)) {\n      if (is.integer(options.angle) && !(options.angle % 90)) {\n        this.options.tileAngle = options.angle;\n      } else {\n        throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);\n      }\n    }\n    // Background colour\n    this._setBackgroundColourOption('tileBackground', options.background);\n    // Depth of tiles\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['onepixel', 'onetile', 'one'])) {\n        this.options.tileDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);\n      }\n    }\n    // Threshold to skip blank tiles\n    if (is.defined(options.skipBlanks)) {\n      if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {\n        this.options.tileSkipBlanks = options.skipBlanks;\n      } else {\n        throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);\n      }\n    } else if (is.defined(options.layout) && options.layout === 'google') {\n      this.options.tileSkipBlanks = 5;\n    }\n    // Center image in tile\n    const centre = is.bool(options.center) ? options.center : options.centre;\n    if (is.defined(centre)) {\n      this._setBooleanOption('tileCentre', centre);\n    }\n    // @id attribute for IIIF layout\n    if (is.defined(options.id)) {\n      if (is.string(options.id)) {\n        this.options.tileId = options.id;\n      } else {\n        throw is.invalidParameterError('id', 'string', options.id);\n      }\n    }\n    // Basename for zip container\n    if (is.defined(options.basename)) {\n      if (is.string(options.basename)) {\n        this.options.tileBasename = options.basename;\n      } else {\n        throw is.invalidParameterError('basename', 'string', options.basename);\n      }\n    }\n  }\n  // Format\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);\n  }\n  return this._updateFormatOut('dz');\n}\n\n/**\n * Set a timeout for processing, in seconds.\n * Use a value of zero to continue processing indefinitely, the default behaviour.\n *\n * The clock starts when libvips opens an input image for processing.\n * Time spent waiting for a libuv thread to become available is not included.\n *\n * @example\n * // Ensure processing takes no longer than 3 seconds\n * try {\n *   const data = await sharp(input)\n *     .blur(1000)\n *     .timeout({ seconds: 3 })\n *     .toBuffer();\n * } catch (err) {\n *   if (err.message.includes('timeout')) { ... }\n * }\n *\n * @since 0.29.2\n *\n * @param {Object} options\n * @param {number} options.seconds - Number of seconds after which processing will be stopped\n * @returns {Sharp}\n */\nfunction timeout (options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'object', options);\n  }\n  if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {\n    this.options.timeoutSeconds = options.seconds;\n  } else {\n    throw is.invalidParameterError('seconds', 'integer between 0 and 3600', options.seconds);\n  }\n  return this;\n}\n\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {string} formatOut\n * @param {Object} [options]\n * @param {boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\nfunction _updateFormatOut (formatOut, options) {\n  if (!(is.object(options) && options.force === false)) {\n    this.options.formatOut = formatOut;\n  }\n  return this;\n}\n\n/**\n * Update a boolean attribute of the this.options Object.\n * @private\n * @param {string} key\n * @param {boolean} val\n * @throws {Error} Invalid key\n */\nfunction _setBooleanOption (key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw is.invalidParameterError(key, 'boolean', val);\n  }\n}\n\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\nfunction _read () {\n  /* istanbul ignore else */\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n    this._pipeline();\n  }\n}\n\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\nfunction _pipeline (callback) {\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, callback);\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, callback);\n    }\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      this.once('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this.emit('info', info);\n            this.push(data);\n          }\n          this.push(null);\n          this.on('end', () => this.emit('close'));\n        });\n      });\n      if (this.streamInFinished) {\n        this.emit('finish');\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          this.emit('error', err);\n        } else {\n          this.emit('info', info);\n          this.push(data);\n        }\n        this.push(null);\n        this.on('end', () => this.emit('close'));\n      });\n    }\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise((resolve, reject) => {\n        this.once('finish', () => {\n          this._flattenBufferIn();\n          sharp.pipeline(this.options, (err, data, info) => {\n            if (err) {\n              reject(err);\n            } else {\n              if (this.options.resolveWithObject) {\n                resolve({ data, info });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise((resolve, reject) => {\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            reject(err);\n          } else {\n            if (this.options.resolveWithObject) {\n              resolve({ data: data, info: info });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    toFile,\n    toBuffer,\n    withMetadata,\n    toFormat,\n    jpeg,\n    jp2,\n    png,\n    webp,\n    tiff,\n    avif,\n    heif,\n    jxl,\n    gif,\n    raw,\n    tile,\n    timeout,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  });\n};\n"]},"metadata":{},"sourceType":"script"}