{"ast":null,"code":"// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n'use strict';\n\nconst color = require('color');\n\nconst is = require('./is');\n\nconst sharp = require('./sharp');\n/**\n * Justication alignment\n * @member\n * @private\n */\n\n\nconst align = {\n  left: 'low',\n  center: 'centre',\n  centre: 'centre',\n  right: 'high'\n};\n/**\n * Extract input options, if any, from an object.\n * @private\n */\n\nfunction _inputOptionsFromObject(obj) {\n  const {\n    raw,\n    density,\n    limitInputPixels,\n    ignoreIcc,\n    unlimited,\n    sequentialRead,\n    failOn,\n    failOnError,\n    animated,\n    page,\n    pages,\n    subifd\n  } = obj;\n  return [raw, density, limitInputPixels, ignoreIcc, unlimited, sequentialRead, failOn, failOnError, animated, page, pages, subifd].some(is.defined) ? {\n    raw,\n    density,\n    limitInputPixels,\n    ignoreIcc,\n    unlimited,\n    sequentialRead,\n    failOn,\n    failOnError,\n    animated,\n    page,\n    pages,\n    subifd\n  } : undefined;\n}\n/**\n * Create Object containing input and input-related options.\n * @private\n */\n\n\nfunction _createInputDescriptor(input, inputOptions, containerOptions) {\n  const inputDescriptor = {\n    failOn: 'warning',\n    limitInputPixels: Math.pow(0x3FFF, 2),\n    ignoreIcc: false,\n    unlimited: false,\n    sequentialRead: true\n  };\n\n  if (is.string(input)) {\n    // filesystem\n    inputDescriptor.file = input;\n  } else if (is.buffer(input)) {\n    // Buffer\n    if (input.length === 0) {\n      throw Error('Input Buffer is empty');\n    }\n\n    inputDescriptor.buffer = input;\n  } else if (is.arrayBuffer(input)) {\n    if (input.byteLength === 0) {\n      throw Error('Input bit Array is empty');\n    }\n\n    inputDescriptor.buffer = Buffer.from(input, 0, input.byteLength);\n  } else if (is.typedArray(input)) {\n    if (input.length === 0) {\n      throw Error('Input Bit Array is empty');\n    }\n\n    inputDescriptor.buffer = Buffer.from(input.buffer, input.byteOffset, input.byteLength);\n  } else if (is.plainObject(input) && !is.defined(inputOptions)) {\n    // Plain Object descriptor, e.g. create\n    inputOptions = input;\n\n    if (_inputOptionsFromObject(inputOptions)) {\n      // Stream with options\n      inputDescriptor.buffer = [];\n    }\n  } else if (!is.defined(input) && !is.defined(inputOptions) && is.object(containerOptions) && containerOptions.allowStream) {\n    // Stream without options\n    inputDescriptor.buffer = [];\n  } else {\n    throw new Error(`Unsupported input '${input}' of type ${typeof input}${is.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ''}`);\n  }\n\n  if (is.object(inputOptions)) {\n    // Deprecated: failOnError\n    if (is.defined(inputOptions.failOnError)) {\n      if (is.bool(inputOptions.failOnError)) {\n        inputDescriptor.failOn = inputOptions.failOnError ? 'warning' : 'none';\n      } else {\n        throw is.invalidParameterError('failOnError', 'boolean', inputOptions.failOnError);\n      }\n    } // failOn\n\n\n    if (is.defined(inputOptions.failOn)) {\n      if (is.string(inputOptions.failOn) && is.inArray(inputOptions.failOn, ['none', 'truncated', 'error', 'warning'])) {\n        inputDescriptor.failOn = inputOptions.failOn;\n      } else {\n        throw is.invalidParameterError('failOn', 'one of: none, truncated, error, warning', inputOptions.failOn);\n      }\n    } // Density\n\n\n    if (is.defined(inputOptions.density)) {\n      if (is.inRange(inputOptions.density, 1, 100000)) {\n        inputDescriptor.density = inputOptions.density;\n      } else {\n        throw is.invalidParameterError('density', 'number between 1 and 100000', inputOptions.density);\n      }\n    } // Ignore embeddded ICC profile\n\n\n    if (is.defined(inputOptions.ignoreIcc)) {\n      if (is.bool(inputOptions.ignoreIcc)) {\n        inputDescriptor.ignoreIcc = inputOptions.ignoreIcc;\n      } else {\n        throw is.invalidParameterError('ignoreIcc', 'boolean', inputOptions.ignoreIcc);\n      }\n    } // limitInputPixels\n\n\n    if (is.defined(inputOptions.limitInputPixels)) {\n      if (is.bool(inputOptions.limitInputPixels)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels ? Math.pow(0x3FFF, 2) : 0;\n      } else if (is.integer(inputOptions.limitInputPixels) && is.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;\n      } else {\n        throw is.invalidParameterError('limitInputPixels', 'positive integer', inputOptions.limitInputPixels);\n      }\n    } // unlimited\n\n\n    if (is.defined(inputOptions.unlimited)) {\n      if (is.bool(inputOptions.unlimited)) {\n        inputDescriptor.unlimited = inputOptions.unlimited;\n      } else {\n        throw is.invalidParameterError('unlimited', 'boolean', inputOptions.unlimited);\n      }\n    } // sequentialRead\n\n\n    if (is.defined(inputOptions.sequentialRead)) {\n      if (is.bool(inputOptions.sequentialRead)) {\n        inputDescriptor.sequentialRead = inputOptions.sequentialRead;\n      } else {\n        throw is.invalidParameterError('sequentialRead', 'boolean', inputOptions.sequentialRead);\n      }\n    } // Raw pixel input\n\n\n    if (is.defined(inputOptions.raw)) {\n      if (is.object(inputOptions.raw) && is.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 && is.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 && is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)) {\n        inputDescriptor.rawWidth = inputOptions.raw.width;\n        inputDescriptor.rawHeight = inputOptions.raw.height;\n        inputDescriptor.rawChannels = inputOptions.raw.channels;\n        inputDescriptor.rawPremultiplied = !!inputOptions.raw.premultiplied;\n\n        switch (input.constructor) {\n          case Uint8Array:\n          case Uint8ClampedArray:\n            inputDescriptor.rawDepth = 'uchar';\n            break;\n\n          case Int8Array:\n            inputDescriptor.rawDepth = 'char';\n            break;\n\n          case Uint16Array:\n            inputDescriptor.rawDepth = 'ushort';\n            break;\n\n          case Int16Array:\n            inputDescriptor.rawDepth = 'short';\n            break;\n\n          case Uint32Array:\n            inputDescriptor.rawDepth = 'uint';\n            break;\n\n          case Int32Array:\n            inputDescriptor.rawDepth = 'int';\n            break;\n\n          case Float32Array:\n            inputDescriptor.rawDepth = 'float';\n            break;\n\n          case Float64Array:\n            inputDescriptor.rawDepth = 'double';\n            break;\n\n          default:\n            inputDescriptor.rawDepth = 'uchar';\n            break;\n        }\n      } else {\n        throw new Error('Expected width, height and channels for raw pixel input');\n      }\n    } // Multi-page input (GIF, TIFF, PDF)\n\n\n    if (is.defined(inputOptions.animated)) {\n      if (is.bool(inputOptions.animated)) {\n        inputDescriptor.pages = inputOptions.animated ? -1 : 1;\n      } else {\n        throw is.invalidParameterError('animated', 'boolean', inputOptions.animated);\n      }\n    }\n\n    if (is.defined(inputOptions.pages)) {\n      if (is.integer(inputOptions.pages) && is.inRange(inputOptions.pages, -1, 100000)) {\n        inputDescriptor.pages = inputOptions.pages;\n      } else {\n        throw is.invalidParameterError('pages', 'integer between -1 and 100000', inputOptions.pages);\n      }\n    }\n\n    if (is.defined(inputOptions.page)) {\n      if (is.integer(inputOptions.page) && is.inRange(inputOptions.page, 0, 100000)) {\n        inputDescriptor.page = inputOptions.page;\n      } else {\n        throw is.invalidParameterError('page', 'integer between 0 and 100000', inputOptions.page);\n      }\n    } // Multi-level input (OpenSlide)\n\n\n    if (is.defined(inputOptions.level)) {\n      if (is.integer(inputOptions.level) && is.inRange(inputOptions.level, 0, 256)) {\n        inputDescriptor.level = inputOptions.level;\n      } else {\n        throw is.invalidParameterError('level', 'integer between 0 and 256', inputOptions.level);\n      }\n    } // Sub Image File Directory (TIFF)\n\n\n    if (is.defined(inputOptions.subifd)) {\n      if (is.integer(inputOptions.subifd) && is.inRange(inputOptions.subifd, -1, 100000)) {\n        inputDescriptor.subifd = inputOptions.subifd;\n      } else {\n        throw is.invalidParameterError('subifd', 'integer between -1 and 100000', inputOptions.subifd);\n      }\n    } // Create new image\n\n\n    if (is.defined(inputOptions.create)) {\n      if (is.object(inputOptions.create) && is.integer(inputOptions.create.width) && inputOptions.create.width > 0 && is.integer(inputOptions.create.height) && inputOptions.create.height > 0 && is.integer(inputOptions.create.channels)) {\n        inputDescriptor.createWidth = inputOptions.create.width;\n        inputDescriptor.createHeight = inputOptions.create.height;\n        inputDescriptor.createChannels = inputOptions.create.channels; // Noise\n\n        if (is.defined(inputOptions.create.noise)) {\n          if (!is.object(inputOptions.create.noise)) {\n            throw new Error('Expected noise to be an object');\n          }\n\n          if (!is.inArray(inputOptions.create.noise.type, ['gaussian'])) {\n            throw new Error('Only gaussian noise is supported at the moment');\n          }\n\n          if (!is.inRange(inputOptions.create.channels, 1, 4)) {\n            throw is.invalidParameterError('create.channels', 'number between 1 and 4', inputOptions.create.channels);\n          }\n\n          inputDescriptor.createNoiseType = inputOptions.create.noise.type;\n\n          if (is.number(inputOptions.create.noise.mean) && is.inRange(inputOptions.create.noise.mean, 0, 10000)) {\n            inputDescriptor.createNoiseMean = inputOptions.create.noise.mean;\n          } else {\n            throw is.invalidParameterError('create.noise.mean', 'number between 0 and 10000', inputOptions.create.noise.mean);\n          }\n\n          if (is.number(inputOptions.create.noise.sigma) && is.inRange(inputOptions.create.noise.sigma, 0, 10000)) {\n            inputDescriptor.createNoiseSigma = inputOptions.create.noise.sigma;\n          } else {\n            throw is.invalidParameterError('create.noise.sigma', 'number between 0 and 10000', inputOptions.create.noise.sigma);\n          }\n        } else if (is.defined(inputOptions.create.background)) {\n          if (!is.inRange(inputOptions.create.channels, 3, 4)) {\n            throw is.invalidParameterError('create.channels', 'number between 3 and 4', inputOptions.create.channels);\n          }\n\n          const background = color(inputOptions.create.background);\n          inputDescriptor.createBackground = [background.red(), background.green(), background.blue(), Math.round(background.alpha() * 255)];\n        } else {\n          throw new Error('Expected valid noise or background to create a new input image');\n        }\n\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected valid width, height and channels to create a new input image');\n      }\n    } // Create a new image with text\n\n\n    if (is.defined(inputOptions.text)) {\n      if (is.object(inputOptions.text) && is.string(inputOptions.text.text)) {\n        inputDescriptor.textValue = inputOptions.text.text;\n\n        if (is.defined(inputOptions.text.height) && is.defined(inputOptions.text.dpi)) {\n          throw new Error('Expected only one of dpi or height');\n        }\n\n        if (is.defined(inputOptions.text.font)) {\n          if (is.string(inputOptions.text.font)) {\n            inputDescriptor.textFont = inputOptions.text.font;\n          } else {\n            throw is.invalidParameterError('text.font', 'string', inputOptions.text.font);\n          }\n        }\n\n        if (is.defined(inputOptions.text.fontfile)) {\n          if (is.string(inputOptions.text.fontfile)) {\n            inputDescriptor.textFontfile = inputOptions.text.fontfile;\n          } else {\n            throw is.invalidParameterError('text.fontfile', 'string', inputOptions.text.fontfile);\n          }\n        }\n\n        if (is.defined(inputOptions.text.width)) {\n          if (is.number(inputOptions.text.width)) {\n            inputDescriptor.textWidth = inputOptions.text.width;\n          } else {\n            throw is.invalidParameterError('text.textWidth', 'number', inputOptions.text.width);\n          }\n        }\n\n        if (is.defined(inputOptions.text.height)) {\n          if (is.number(inputOptions.text.height)) {\n            inputDescriptor.textHeight = inputOptions.text.height;\n          } else {\n            throw is.invalidParameterError('text.height', 'number', inputOptions.text.height);\n          }\n        }\n\n        if (is.defined(inputOptions.text.align)) {\n          if (is.string(inputOptions.text.align) && is.string(this.constructor.align[inputOptions.text.align])) {\n            inputDescriptor.textAlign = this.constructor.align[inputOptions.text.align];\n          } else {\n            throw is.invalidParameterError('text.align', 'valid alignment', inputOptions.text.align);\n          }\n        }\n\n        if (is.defined(inputOptions.text.justify)) {\n          if (is.bool(inputOptions.text.justify)) {\n            inputDescriptor.textJustify = inputOptions.text.justify;\n          } else {\n            throw is.invalidParameterError('text.justify', 'boolean', inputOptions.text.justify);\n          }\n        }\n\n        if (is.defined(inputOptions.text.dpi)) {\n          if (is.number(inputOptions.text.dpi) && is.inRange(inputOptions.text.dpi, 1, 100000)) {\n            inputDescriptor.textDpi = inputOptions.text.dpi;\n          } else {\n            throw is.invalidParameterError('text.dpi', 'number between 1 and 100000', inputOptions.text.dpi);\n          }\n        }\n\n        if (is.defined(inputOptions.text.rgba)) {\n          if (is.bool(inputOptions.text.rgba)) {\n            inputDescriptor.textRgba = inputOptions.text.rgba;\n          } else {\n            throw is.invalidParameterError('text.rgba', 'bool', inputOptions.text.rgba);\n          }\n        }\n\n        if (is.defined(inputOptions.text.spacing)) {\n          if (is.number(inputOptions.text.spacing)) {\n            inputDescriptor.textSpacing = inputOptions.text.spacing;\n          } else {\n            throw is.invalidParameterError('text.spacing', 'number', inputOptions.text.spacing);\n          }\n        }\n\n        if (is.defined(inputOptions.text.wrap)) {\n          if (is.string(inputOptions.text.wrap) && is.inArray(inputOptions.text.wrap, ['word', 'char', 'wordChar', 'none'])) {\n            inputDescriptor.textWrap = inputOptions.text.wrap;\n          } else {\n            throw is.invalidParameterError('text.wrap', 'one of: word, char, wordChar, none', inputOptions.text.wrap);\n          }\n        }\n\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected a valid string to create an image with text.');\n      }\n    }\n  } else if (is.defined(inputOptions)) {\n    throw new Error('Invalid input options ' + inputOptions);\n  }\n\n  return inputDescriptor;\n}\n/**\n * Handle incoming Buffer chunk on Writable Stream.\n * @private\n * @param {Buffer} chunk\n * @param {string} encoding - unused\n * @param {Function} callback\n */\n\n\nfunction _write(chunk, encoding, callback) {\n  /* istanbul ignore else */\n  if (Array.isArray(this.options.input.buffer)) {\n    /* istanbul ignore else */\n    if (is.buffer(chunk)) {\n      if (this.options.input.buffer.length === 0) {\n        this.on('finish', () => {\n          this.streamInFinished = true;\n        });\n      }\n\n      this.options.input.buffer.push(chunk);\n      callback();\n    } else {\n      callback(new Error('Non-Buffer data on Writable Stream'));\n    }\n  } else {\n    callback(new Error('Unexpected data on Writable Stream'));\n  }\n}\n/**\n * Flattens the array of chunks accumulated in input.buffer.\n * @private\n */\n\n\nfunction _flattenBufferIn() {\n  if (this._isStreamInput()) {\n    this.options.input.buffer = Buffer.concat(this.options.input.buffer);\n  }\n}\n/**\n * Are we expecting Stream-based input?\n * @private\n * @returns {boolean}\n */\n\n\nfunction _isStreamInput() {\n  return Array.isArray(this.options.input.buffer);\n}\n/**\n * Fast access to (uncached) image metadata without decoding any compressed pixel data.\n *\n * This is read from the header of the input image.\n * It does not take into consideration any operations to be applied to the output image,\n * such as resize or rotate.\n *\n * Dimensions in the response will respect the `page` and `pages` properties of the\n * {@link /api-constructor#parameters|constructor parameters}.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `format`: Name of decoder used to decompress image data e.g. `jpeg`, `png`, `webp`, `gif`, `svg`\n * - `size`: Total size of image in bytes, for Stream and Buffer input only\n * - `width`: Number of pixels wide (EXIF orientation is not taken into consideration, see example below)\n * - `height`: Number of pixels high (EXIF orientation is not taken into consideration, see example below)\n * - `space`: Name of colour space interpretation e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://www.libvips.org/API/current/VipsImage.html#VipsInterpretation)\n * - `channels`: Number of bands e.g. `3` for sRGB, `4` for CMYK\n * - `depth`: Name of pixel depth format e.g. `uchar`, `char`, `ushort`, `float` [...](https://www.libvips.org/API/current/VipsImage.html#VipsBandFormat)\n * - `density`: Number of pixels per inch (DPI), if present\n * - `chromaSubsampling`: String containing JPEG chroma subsampling, `4:2:0` or `4:4:4` for RGB, `4:2:0:4` or `4:4:4:4` for CMYK\n * - `isProgressive`: Boolean indicating whether the image is interlaced using a progressive scan\n * - `pages`: Number of pages/frames contained within the image, with support for TIFF, HEIF, PDF, animated GIF and animated WebP\n * - `pageHeight`: Number of pixels high each page in a multi-page image will be.\n * - `loop`: Number of times to loop an animated image, zero refers to a continuous loop.\n * - `delay`: Delay in ms between each page in an animated image, provided as an array of integers.\n * - `pagePrimary`: Number of the primary page in a HEIF image\n * - `levels`: Details of each level in a multi-level image provided as an array of objects, requires libvips compiled with support for OpenSlide\n * - `subifds`: Number of Sub Image File Directories in an OME-TIFF image\n * - `background`: Default background colour, if present, for PNG (bKGD) and GIF images, either an RGB Object or a single greyscale value\n * - `compression`: The encoder used to compress an HEIF file, `av1` (AVIF) or `hevc` (HEIC)\n * - `resolutionUnit`: The unit of resolution (density), either `inch` or `cm`, if present\n * - `hasProfile`: Boolean indicating the presence of an embedded ICC profile\n * - `hasAlpha`: Boolean indicating the presence of an alpha transparency channel\n * - `orientation`: Number value of the EXIF Orientation header, if present\n * - `exif`: Buffer containing raw EXIF data, if present\n * - `icc`: Buffer containing raw [ICC](https://www.npmjs.com/package/icc) profile data, if present\n * - `iptc`: Buffer containing raw IPTC data, if present\n * - `xmp`: Buffer containing raw XMP data, if present\n * - `tifftagPhotoshop`: Buffer containing raw TIFFTAG_PHOTOSHOP data, if present\n * - `formatMagick`: String containing format for images loaded via *magick\n *\n * @example\n * const metadata = await sharp(input).metadata();\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .metadata()\n *   .then(function(metadata) {\n *     return image\n *       .resize(Math.round(metadata.width / 2))\n *       .webp()\n *       .toBuffer();\n *   })\n *   .then(function(data) {\n *     // data contains a WebP image half the width and height of the original JPEG\n *   });\n *\n * @example\n * // Based on EXIF rotation metadata, get the right-side-up width and height:\n *\n * const size = getNormalSize(await sharp(input).metadata());\n *\n * function getNormalSize({ width, height, orientation }) {\n *   return (orientation || 0) >= 5\n *     ? { width: height, height: width }\n *     : { width, height };\n * }\n *\n * @param {Function} [callback] - called with the arguments `(err, metadata)`\n * @returns {Promise<Object>|Sharp}\n */\n\n\nfunction metadata(callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n\n        sharp.metadata(this.options, callback);\n      });\n    } else {\n      sharp.metadata(this.options, callback);\n    }\n\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        const finished = () => {\n          this._flattenBufferIn();\n\n          sharp.metadata(this.options, (err, metadata) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(metadata);\n            }\n          });\n        };\n\n        if (this.writableFinished) {\n          finished();\n        } else {\n          this.once('finish', finished);\n        }\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.metadata(this.options, (err, metadata) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(metadata);\n          }\n        });\n      });\n    }\n  }\n}\n/**\n * Access to pixel-derived image statistics for every channel in the image.\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `channels`: Array of channel statistics for each channel in the image. Each channel statistic contains\n *     - `min` (minimum value in the channel)\n *     - `max` (maximum value in the channel)\n *     - `sum` (sum of all values in a channel)\n *     - `squaresSum` (sum of squared values in a channel)\n *     - `mean` (mean of the values in a channel)\n *     - `stdev` (standard deviation for the values in a channel)\n *     - `minX` (x-coordinate of one of the pixel where the minimum lies)\n *     - `minY` (y-coordinate of one of the pixel where the minimum lies)\n *     - `maxX` (x-coordinate of one of the pixel where the maximum lies)\n *     - `maxY` (y-coordinate of one of the pixel where the maximum lies)\n * - `isOpaque`: Is the image fully opaque? Will be `true` if the image has no alpha channel or if every pixel is fully opaque.\n * - `entropy`: Histogram-based estimation of greyscale entropy, discarding alpha channel if any.\n * - `sharpness`: Estimation of greyscale sharpness based on the standard deviation of a Laplacian convolution, discarding alpha channel if any.\n * - `dominant`: Object containing most dominant sRGB colour based on a 4096-bin 3D histogram.\n *\n * **Note**: Statistics are derived from the original input image. Any operations performed on the image must first be\n * written to a buffer in order to run `stats` on the result (see third example).\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .stats()\n *   .then(function(stats) {\n *      // stats contains the channel-wise statistics array and the isOpaque value\n *   });\n *\n * @example\n * const { entropy, sharpness, dominant } = await sharp(input).stats();\n * const { r, g, b } = dominant;\n *\n * @example\n * const image = sharp(input);\n * // store intermediate result\n * const part = await image.extract(region).toBuffer();\n * // create new instance to obtain statistics of extracted region\n * const stats = await sharp(part).stats();\n *\n * @param {Function} [callback] - called with the arguments `(err, stats)`\n * @returns {Promise<Object>}\n */\n\n\nfunction stats(callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n\n        sharp.stats(this.options, callback);\n      });\n    } else {\n      sharp.stats(this.options, callback);\n    }\n\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        this.on('finish', function () {\n          this._flattenBufferIn();\n\n          sharp.stats(this.options, (err, stats) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(stats);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.stats(this.options, (err, stats) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(stats);\n          }\n        });\n      });\n    }\n  }\n}\n/**\n * Decorate the Sharp prototype with input-related functions.\n * @private\n */\n\n\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Private\n    _inputOptionsFromObject,\n    _createInputDescriptor,\n    _write,\n    _flattenBufferIn,\n    _isStreamInput,\n    // Public\n    metadata,\n    stats\n  }); // Class attributes\n\n  Sharp.align = align;\n};","map":{"version":3,"sources":["D:/VS_Code/VS_Code_general_Workspace/finalYearProject/chatApp/node_modules/sharp/lib/input.js"],"names":["color","require","is","sharp","align","left","center","centre","right","_inputOptionsFromObject","obj","raw","density","limitInputPixels","ignoreIcc","unlimited","sequentialRead","failOn","failOnError","animated","page","pages","subifd","some","defined","undefined","_createInputDescriptor","input","inputOptions","containerOptions","inputDescriptor","Math","pow","string","file","buffer","length","Error","arrayBuffer","byteLength","Buffer","from","typedArray","byteOffset","plainObject","object","allowStream","bool","invalidParameterError","inArray","inRange","integer","Number","MAX_SAFE_INTEGER","width","height","channels","rawWidth","rawHeight","rawChannels","rawPremultiplied","premultiplied","constructor","Uint8Array","Uint8ClampedArray","rawDepth","Int8Array","Uint16Array","Int16Array","Uint32Array","Int32Array","Float32Array","Float64Array","level","create","createWidth","createHeight","createChannels","noise","type","createNoiseType","number","mean","createNoiseMean","sigma","createNoiseSigma","background","createBackground","red","green","blue","round","alpha","text","textValue","dpi","font","textFont","fontfile","textFontfile","textWidth","textHeight","textAlign","justify","textJustify","textDpi","rgba","textRgba","spacing","textSpacing","wrap","textWrap","_write","chunk","encoding","callback","Array","isArray","options","on","streamInFinished","push","_flattenBufferIn","_isStreamInput","concat","metadata","fn","Promise","resolve","reject","finished","err","writableFinished","once","stats","module","exports","Sharp","Object","assign","prototype"],"mappings":"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","sourcesContent":["// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst color = require('color');\nconst is = require('./is');\nconst sharp = require('./sharp');\n\n/**\n * Justication alignment\n * @member\n * @private\n */\nconst align = {\n  left: 'low',\n  center: 'centre',\n  centre: 'centre',\n  right: 'high'\n};\n\n/**\n * Extract input options, if any, from an object.\n * @private\n */\nfunction _inputOptionsFromObject (obj) {\n  const { raw, density, limitInputPixels, ignoreIcc, unlimited, sequentialRead, failOn, failOnError, animated, page, pages, subifd } = obj;\n  return [raw, density, limitInputPixels, ignoreIcc, unlimited, sequentialRead, failOn, failOnError, animated, page, pages, subifd].some(is.defined)\n    ? { raw, density, limitInputPixels, ignoreIcc, unlimited, sequentialRead, failOn, failOnError, animated, page, pages, subifd }\n    : undefined;\n}\n\n/**\n * Create Object containing input and input-related options.\n * @private\n */\nfunction _createInputDescriptor (input, inputOptions, containerOptions) {\n  const inputDescriptor = {\n    failOn: 'warning',\n    limitInputPixels: Math.pow(0x3FFF, 2),\n    ignoreIcc: false,\n    unlimited: false,\n    sequentialRead: true\n  };\n  if (is.string(input)) {\n    // filesystem\n    inputDescriptor.file = input;\n  } else if (is.buffer(input)) {\n    // Buffer\n    if (input.length === 0) {\n      throw Error('Input Buffer is empty');\n    }\n    inputDescriptor.buffer = input;\n  } else if (is.arrayBuffer(input)) {\n    if (input.byteLength === 0) {\n      throw Error('Input bit Array is empty');\n    }\n    inputDescriptor.buffer = Buffer.from(input, 0, input.byteLength);\n  } else if (is.typedArray(input)) {\n    if (input.length === 0) {\n      throw Error('Input Bit Array is empty');\n    }\n    inputDescriptor.buffer = Buffer.from(input.buffer, input.byteOffset, input.byteLength);\n  } else if (is.plainObject(input) && !is.defined(inputOptions)) {\n    // Plain Object descriptor, e.g. create\n    inputOptions = input;\n    if (_inputOptionsFromObject(inputOptions)) {\n      // Stream with options\n      inputDescriptor.buffer = [];\n    }\n  } else if (!is.defined(input) && !is.defined(inputOptions) && is.object(containerOptions) && containerOptions.allowStream) {\n    // Stream without options\n    inputDescriptor.buffer = [];\n  } else {\n    throw new Error(`Unsupported input '${input}' of type ${typeof input}${\n      is.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ''\n    }`);\n  }\n  if (is.object(inputOptions)) {\n    // Deprecated: failOnError\n    if (is.defined(inputOptions.failOnError)) {\n      if (is.bool(inputOptions.failOnError)) {\n        inputDescriptor.failOn = inputOptions.failOnError ? 'warning' : 'none';\n      } else {\n        throw is.invalidParameterError('failOnError', 'boolean', inputOptions.failOnError);\n      }\n    }\n    // failOn\n    if (is.defined(inputOptions.failOn)) {\n      if (is.string(inputOptions.failOn) && is.inArray(inputOptions.failOn, ['none', 'truncated', 'error', 'warning'])) {\n        inputDescriptor.failOn = inputOptions.failOn;\n      } else {\n        throw is.invalidParameterError('failOn', 'one of: none, truncated, error, warning', inputOptions.failOn);\n      }\n    }\n    // Density\n    if (is.defined(inputOptions.density)) {\n      if (is.inRange(inputOptions.density, 1, 100000)) {\n        inputDescriptor.density = inputOptions.density;\n      } else {\n        throw is.invalidParameterError('density', 'number between 1 and 100000', inputOptions.density);\n      }\n    }\n    // Ignore embeddded ICC profile\n    if (is.defined(inputOptions.ignoreIcc)) {\n      if (is.bool(inputOptions.ignoreIcc)) {\n        inputDescriptor.ignoreIcc = inputOptions.ignoreIcc;\n      } else {\n        throw is.invalidParameterError('ignoreIcc', 'boolean', inputOptions.ignoreIcc);\n      }\n    }\n    // limitInputPixels\n    if (is.defined(inputOptions.limitInputPixels)) {\n      if (is.bool(inputOptions.limitInputPixels)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels\n          ? Math.pow(0x3FFF, 2)\n          : 0;\n      } else if (is.integer(inputOptions.limitInputPixels) && is.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;\n      } else {\n        throw is.invalidParameterError('limitInputPixels', 'positive integer', inputOptions.limitInputPixels);\n      }\n    }\n    // unlimited\n    if (is.defined(inputOptions.unlimited)) {\n      if (is.bool(inputOptions.unlimited)) {\n        inputDescriptor.unlimited = inputOptions.unlimited;\n      } else {\n        throw is.invalidParameterError('unlimited', 'boolean', inputOptions.unlimited);\n      }\n    }\n    // sequentialRead\n    if (is.defined(inputOptions.sequentialRead)) {\n      if (is.bool(inputOptions.sequentialRead)) {\n        inputDescriptor.sequentialRead = inputOptions.sequentialRead;\n      } else {\n        throw is.invalidParameterError('sequentialRead', 'boolean', inputOptions.sequentialRead);\n      }\n    }\n    // Raw pixel input\n    if (is.defined(inputOptions.raw)) {\n      if (\n        is.object(inputOptions.raw) &&\n        is.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 &&\n        is.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 &&\n        is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)\n      ) {\n        inputDescriptor.rawWidth = inputOptions.raw.width;\n        inputDescriptor.rawHeight = inputOptions.raw.height;\n        inputDescriptor.rawChannels = inputOptions.raw.channels;\n        inputDescriptor.rawPremultiplied = !!inputOptions.raw.premultiplied;\n\n        switch (input.constructor) {\n          case Uint8Array:\n          case Uint8ClampedArray:\n            inputDescriptor.rawDepth = 'uchar';\n            break;\n          case Int8Array:\n            inputDescriptor.rawDepth = 'char';\n            break;\n          case Uint16Array:\n            inputDescriptor.rawDepth = 'ushort';\n            break;\n          case Int16Array:\n            inputDescriptor.rawDepth = 'short';\n            break;\n          case Uint32Array:\n            inputDescriptor.rawDepth = 'uint';\n            break;\n          case Int32Array:\n            inputDescriptor.rawDepth = 'int';\n            break;\n          case Float32Array:\n            inputDescriptor.rawDepth = 'float';\n            break;\n          case Float64Array:\n            inputDescriptor.rawDepth = 'double';\n            break;\n          default:\n            inputDescriptor.rawDepth = 'uchar';\n            break;\n        }\n      } else {\n        throw new Error('Expected width, height and channels for raw pixel input');\n      }\n    }\n    // Multi-page input (GIF, TIFF, PDF)\n    if (is.defined(inputOptions.animated)) {\n      if (is.bool(inputOptions.animated)) {\n        inputDescriptor.pages = inputOptions.animated ? -1 : 1;\n      } else {\n        throw is.invalidParameterError('animated', 'boolean', inputOptions.animated);\n      }\n    }\n    if (is.defined(inputOptions.pages)) {\n      if (is.integer(inputOptions.pages) && is.inRange(inputOptions.pages, -1, 100000)) {\n        inputDescriptor.pages = inputOptions.pages;\n      } else {\n        throw is.invalidParameterError('pages', 'integer between -1 and 100000', inputOptions.pages);\n      }\n    }\n    if (is.defined(inputOptions.page)) {\n      if (is.integer(inputOptions.page) && is.inRange(inputOptions.page, 0, 100000)) {\n        inputDescriptor.page = inputOptions.page;\n      } else {\n        throw is.invalidParameterError('page', 'integer between 0 and 100000', inputOptions.page);\n      }\n    }\n    // Multi-level input (OpenSlide)\n    if (is.defined(inputOptions.level)) {\n      if (is.integer(inputOptions.level) && is.inRange(inputOptions.level, 0, 256)) {\n        inputDescriptor.level = inputOptions.level;\n      } else {\n        throw is.invalidParameterError('level', 'integer between 0 and 256', inputOptions.level);\n      }\n    }\n    // Sub Image File Directory (TIFF)\n    if (is.defined(inputOptions.subifd)) {\n      if (is.integer(inputOptions.subifd) && is.inRange(inputOptions.subifd, -1, 100000)) {\n        inputDescriptor.subifd = inputOptions.subifd;\n      } else {\n        throw is.invalidParameterError('subifd', 'integer between -1 and 100000', inputOptions.subifd);\n      }\n    }\n    // Create new image\n    if (is.defined(inputOptions.create)) {\n      if (\n        is.object(inputOptions.create) &&\n        is.integer(inputOptions.create.width) && inputOptions.create.width > 0 &&\n        is.integer(inputOptions.create.height) && inputOptions.create.height > 0 &&\n        is.integer(inputOptions.create.channels)\n      ) {\n        inputDescriptor.createWidth = inputOptions.create.width;\n        inputDescriptor.createHeight = inputOptions.create.height;\n        inputDescriptor.createChannels = inputOptions.create.channels;\n        // Noise\n        if (is.defined(inputOptions.create.noise)) {\n          if (!is.object(inputOptions.create.noise)) {\n            throw new Error('Expected noise to be an object');\n          }\n          if (!is.inArray(inputOptions.create.noise.type, ['gaussian'])) {\n            throw new Error('Only gaussian noise is supported at the moment');\n          }\n          if (!is.inRange(inputOptions.create.channels, 1, 4)) {\n            throw is.invalidParameterError('create.channels', 'number between 1 and 4', inputOptions.create.channels);\n          }\n          inputDescriptor.createNoiseType = inputOptions.create.noise.type;\n          if (is.number(inputOptions.create.noise.mean) && is.inRange(inputOptions.create.noise.mean, 0, 10000)) {\n            inputDescriptor.createNoiseMean = inputOptions.create.noise.mean;\n          } else {\n            throw is.invalidParameterError('create.noise.mean', 'number between 0 and 10000', inputOptions.create.noise.mean);\n          }\n          if (is.number(inputOptions.create.noise.sigma) && is.inRange(inputOptions.create.noise.sigma, 0, 10000)) {\n            inputDescriptor.createNoiseSigma = inputOptions.create.noise.sigma;\n          } else {\n            throw is.invalidParameterError('create.noise.sigma', 'number between 0 and 10000', inputOptions.create.noise.sigma);\n          }\n        } else if (is.defined(inputOptions.create.background)) {\n          if (!is.inRange(inputOptions.create.channels, 3, 4)) {\n            throw is.invalidParameterError('create.channels', 'number between 3 and 4', inputOptions.create.channels);\n          }\n          const background = color(inputOptions.create.background);\n          inputDescriptor.createBackground = [\n            background.red(),\n            background.green(),\n            background.blue(),\n            Math.round(background.alpha() * 255)\n          ];\n        } else {\n          throw new Error('Expected valid noise or background to create a new input image');\n        }\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected valid width, height and channels to create a new input image');\n      }\n    }\n    // Create a new image with text\n    if (is.defined(inputOptions.text)) {\n      if (is.object(inputOptions.text) && is.string(inputOptions.text.text)) {\n        inputDescriptor.textValue = inputOptions.text.text;\n        if (is.defined(inputOptions.text.height) && is.defined(inputOptions.text.dpi)) {\n          throw new Error('Expected only one of dpi or height');\n        }\n        if (is.defined(inputOptions.text.font)) {\n          if (is.string(inputOptions.text.font)) {\n            inputDescriptor.textFont = inputOptions.text.font;\n          } else {\n            throw is.invalidParameterError('text.font', 'string', inputOptions.text.font);\n          }\n        }\n        if (is.defined(inputOptions.text.fontfile)) {\n          if (is.string(inputOptions.text.fontfile)) {\n            inputDescriptor.textFontfile = inputOptions.text.fontfile;\n          } else {\n            throw is.invalidParameterError('text.fontfile', 'string', inputOptions.text.fontfile);\n          }\n        }\n        if (is.defined(inputOptions.text.width)) {\n          if (is.number(inputOptions.text.width)) {\n            inputDescriptor.textWidth = inputOptions.text.width;\n          } else {\n            throw is.invalidParameterError('text.textWidth', 'number', inputOptions.text.width);\n          }\n        }\n        if (is.defined(inputOptions.text.height)) {\n          if (is.number(inputOptions.text.height)) {\n            inputDescriptor.textHeight = inputOptions.text.height;\n          } else {\n            throw is.invalidParameterError('text.height', 'number', inputOptions.text.height);\n          }\n        }\n        if (is.defined(inputOptions.text.align)) {\n          if (is.string(inputOptions.text.align) && is.string(this.constructor.align[inputOptions.text.align])) {\n            inputDescriptor.textAlign = this.constructor.align[inputOptions.text.align];\n          } else {\n            throw is.invalidParameterError('text.align', 'valid alignment', inputOptions.text.align);\n          }\n        }\n        if (is.defined(inputOptions.text.justify)) {\n          if (is.bool(inputOptions.text.justify)) {\n            inputDescriptor.textJustify = inputOptions.text.justify;\n          } else {\n            throw is.invalidParameterError('text.justify', 'boolean', inputOptions.text.justify);\n          }\n        }\n        if (is.defined(inputOptions.text.dpi)) {\n          if (is.number(inputOptions.text.dpi) && is.inRange(inputOptions.text.dpi, 1, 100000)) {\n            inputDescriptor.textDpi = inputOptions.text.dpi;\n          } else {\n            throw is.invalidParameterError('text.dpi', 'number between 1 and 100000', inputOptions.text.dpi);\n          }\n        }\n        if (is.defined(inputOptions.text.rgba)) {\n          if (is.bool(inputOptions.text.rgba)) {\n            inputDescriptor.textRgba = inputOptions.text.rgba;\n          } else {\n            throw is.invalidParameterError('text.rgba', 'bool', inputOptions.text.rgba);\n          }\n        }\n        if (is.defined(inputOptions.text.spacing)) {\n          if (is.number(inputOptions.text.spacing)) {\n            inputDescriptor.textSpacing = inputOptions.text.spacing;\n          } else {\n            throw is.invalidParameterError('text.spacing', 'number', inputOptions.text.spacing);\n          }\n        }\n        if (is.defined(inputOptions.text.wrap)) {\n          if (is.string(inputOptions.text.wrap) && is.inArray(inputOptions.text.wrap, ['word', 'char', 'wordChar', 'none'])) {\n            inputDescriptor.textWrap = inputOptions.text.wrap;\n          } else {\n            throw is.invalidParameterError('text.wrap', 'one of: word, char, wordChar, none', inputOptions.text.wrap);\n          }\n        }\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected a valid string to create an image with text.');\n      }\n    }\n  } else if (is.defined(inputOptions)) {\n    throw new Error('Invalid input options ' + inputOptions);\n  }\n  return inputDescriptor;\n}\n\n/**\n * Handle incoming Buffer chunk on Writable Stream.\n * @private\n * @param {Buffer} chunk\n * @param {string} encoding - unused\n * @param {Function} callback\n */\nfunction _write (chunk, encoding, callback) {\n  /* istanbul ignore else */\n  if (Array.isArray(this.options.input.buffer)) {\n    /* istanbul ignore else */\n    if (is.buffer(chunk)) {\n      if (this.options.input.buffer.length === 0) {\n        this.on('finish', () => {\n          this.streamInFinished = true;\n        });\n      }\n      this.options.input.buffer.push(chunk);\n      callback();\n    } else {\n      callback(new Error('Non-Buffer data on Writable Stream'));\n    }\n  } else {\n    callback(new Error('Unexpected data on Writable Stream'));\n  }\n}\n\n/**\n * Flattens the array of chunks accumulated in input.buffer.\n * @private\n */\nfunction _flattenBufferIn () {\n  if (this._isStreamInput()) {\n    this.options.input.buffer = Buffer.concat(this.options.input.buffer);\n  }\n}\n\n/**\n * Are we expecting Stream-based input?\n * @private\n * @returns {boolean}\n */\nfunction _isStreamInput () {\n  return Array.isArray(this.options.input.buffer);\n}\n\n/**\n * Fast access to (uncached) image metadata without decoding any compressed pixel data.\n *\n * This is read from the header of the input image.\n * It does not take into consideration any operations to be applied to the output image,\n * such as resize or rotate.\n *\n * Dimensions in the response will respect the `page` and `pages` properties of the\n * {@link /api-constructor#parameters|constructor parameters}.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `format`: Name of decoder used to decompress image data e.g. `jpeg`, `png`, `webp`, `gif`, `svg`\n * - `size`: Total size of image in bytes, for Stream and Buffer input only\n * - `width`: Number of pixels wide (EXIF orientation is not taken into consideration, see example below)\n * - `height`: Number of pixels high (EXIF orientation is not taken into consideration, see example below)\n * - `space`: Name of colour space interpretation e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://www.libvips.org/API/current/VipsImage.html#VipsInterpretation)\n * - `channels`: Number of bands e.g. `3` for sRGB, `4` for CMYK\n * - `depth`: Name of pixel depth format e.g. `uchar`, `char`, `ushort`, `float` [...](https://www.libvips.org/API/current/VipsImage.html#VipsBandFormat)\n * - `density`: Number of pixels per inch (DPI), if present\n * - `chromaSubsampling`: String containing JPEG chroma subsampling, `4:2:0` or `4:4:4` for RGB, `4:2:0:4` or `4:4:4:4` for CMYK\n * - `isProgressive`: Boolean indicating whether the image is interlaced using a progressive scan\n * - `pages`: Number of pages/frames contained within the image, with support for TIFF, HEIF, PDF, animated GIF and animated WebP\n * - `pageHeight`: Number of pixels high each page in a multi-page image will be.\n * - `loop`: Number of times to loop an animated image, zero refers to a continuous loop.\n * - `delay`: Delay in ms between each page in an animated image, provided as an array of integers.\n * - `pagePrimary`: Number of the primary page in a HEIF image\n * - `levels`: Details of each level in a multi-level image provided as an array of objects, requires libvips compiled with support for OpenSlide\n * - `subifds`: Number of Sub Image File Directories in an OME-TIFF image\n * - `background`: Default background colour, if present, for PNG (bKGD) and GIF images, either an RGB Object or a single greyscale value\n * - `compression`: The encoder used to compress an HEIF file, `av1` (AVIF) or `hevc` (HEIC)\n * - `resolutionUnit`: The unit of resolution (density), either `inch` or `cm`, if present\n * - `hasProfile`: Boolean indicating the presence of an embedded ICC profile\n * - `hasAlpha`: Boolean indicating the presence of an alpha transparency channel\n * - `orientation`: Number value of the EXIF Orientation header, if present\n * - `exif`: Buffer containing raw EXIF data, if present\n * - `icc`: Buffer containing raw [ICC](https://www.npmjs.com/package/icc) profile data, if present\n * - `iptc`: Buffer containing raw IPTC data, if present\n * - `xmp`: Buffer containing raw XMP data, if present\n * - `tifftagPhotoshop`: Buffer containing raw TIFFTAG_PHOTOSHOP data, if present\n * - `formatMagick`: String containing format for images loaded via *magick\n *\n * @example\n * const metadata = await sharp(input).metadata();\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .metadata()\n *   .then(function(metadata) {\n *     return image\n *       .resize(Math.round(metadata.width / 2))\n *       .webp()\n *       .toBuffer();\n *   })\n *   .then(function(data) {\n *     // data contains a WebP image half the width and height of the original JPEG\n *   });\n *\n * @example\n * // Based on EXIF rotation metadata, get the right-side-up width and height:\n *\n * const size = getNormalSize(await sharp(input).metadata());\n *\n * function getNormalSize({ width, height, orientation }) {\n *   return (orientation || 0) >= 5\n *     ? { width: height, height: width }\n *     : { width, height };\n * }\n *\n * @param {Function} [callback] - called with the arguments `(err, metadata)`\n * @returns {Promise<Object>|Sharp}\n */\nfunction metadata (callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.metadata(this.options, callback);\n      });\n    } else {\n      sharp.metadata(this.options, callback);\n    }\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        const finished = () => {\n          this._flattenBufferIn();\n          sharp.metadata(this.options, (err, metadata) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(metadata);\n            }\n          });\n        };\n        if (this.writableFinished) {\n          finished();\n        } else {\n          this.once('finish', finished);\n        }\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.metadata(this.options, (err, metadata) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(metadata);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Access to pixel-derived image statistics for every channel in the image.\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `channels`: Array of channel statistics for each channel in the image. Each channel statistic contains\n *     - `min` (minimum value in the channel)\n *     - `max` (maximum value in the channel)\n *     - `sum` (sum of all values in a channel)\n *     - `squaresSum` (sum of squared values in a channel)\n *     - `mean` (mean of the values in a channel)\n *     - `stdev` (standard deviation for the values in a channel)\n *     - `minX` (x-coordinate of one of the pixel where the minimum lies)\n *     - `minY` (y-coordinate of one of the pixel where the minimum lies)\n *     - `maxX` (x-coordinate of one of the pixel where the maximum lies)\n *     - `maxY` (y-coordinate of one of the pixel where the maximum lies)\n * - `isOpaque`: Is the image fully opaque? Will be `true` if the image has no alpha channel or if every pixel is fully opaque.\n * - `entropy`: Histogram-based estimation of greyscale entropy, discarding alpha channel if any.\n * - `sharpness`: Estimation of greyscale sharpness based on the standard deviation of a Laplacian convolution, discarding alpha channel if any.\n * - `dominant`: Object containing most dominant sRGB colour based on a 4096-bin 3D histogram.\n *\n * **Note**: Statistics are derived from the original input image. Any operations performed on the image must first be\n * written to a buffer in order to run `stats` on the result (see third example).\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .stats()\n *   .then(function(stats) {\n *      // stats contains the channel-wise statistics array and the isOpaque value\n *   });\n *\n * @example\n * const { entropy, sharpness, dominant } = await sharp(input).stats();\n * const { r, g, b } = dominant;\n *\n * @example\n * const image = sharp(input);\n * // store intermediate result\n * const part = await image.extract(region).toBuffer();\n * // create new instance to obtain statistics of extracted region\n * const stats = await sharp(part).stats();\n *\n * @param {Function} [callback] - called with the arguments `(err, stats)`\n * @returns {Promise<Object>}\n */\nfunction stats (callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.stats(this.options, callback);\n      });\n    } else {\n      sharp.stats(this.options, callback);\n    }\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        this.on('finish', function () {\n          this._flattenBufferIn();\n          sharp.stats(this.options, (err, stats) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(stats);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.stats(this.options, (err, stats) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(stats);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with input-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Private\n    _inputOptionsFromObject,\n    _createInputDescriptor,\n    _write,\n    _flattenBufferIn,\n    _isStreamInput,\n    // Public\n    metadata,\n    stats\n  });\n  // Class attributes\n  Sharp.align = align;\n};\n"]},"metadata":{},"sourceType":"script"}